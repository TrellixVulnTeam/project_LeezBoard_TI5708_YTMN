<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IMGLIB: IMG_histogram_16</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>IMG_histogram_16</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_m_g__histogram__16.html#g35c559c4ff5d33722288acac8f78675b">IMG_histogram_16</a> (unsigned short *restrict image, int n, int accumulate, short *restrict t_hist, short *restrict hist, int img_bits)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g35c559c4ff5d33722288acac8f78675b"></a><!-- doxytag: member="c66/IMG_histogram_16.h::IMG_histogram_16" ref="g35c559c4ff5d33722288acac8f78675b" args="(unsigned short *restrict image, int n, int accumulate, short *restrict t_hist, short *restrict hist, int img_bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMG_histogram_16           </td>
          <td>(</td>
          <td class="paramtype">unsigned short *restrict&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>accumulate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *restrict&nbsp;</td>
          <td class="paramname"> <em>t_hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *restrict&nbsp;</td>
          <td class="paramname"> <em>hist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>img_bits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>This code calculates the histogram of an image array "image" containing "n" pixels, with "img_bits" valid data bits per pixel. It returns a histogram with 2^img_bits bins, one for each of the possible pixel values based on the precision. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The routine can either add-to or subtract-from an existing histogram, through the "accumulate" control. The implementation requires temporary storage for 4 scratch histograms, to reduce bank conflicts. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The length of the "hist" and "t_hist" arrays depend on the pixel precision as specified by "img_bits". The length of "hist" is 2^img_bits and that of "t_hist" is 2^(img_bits+2) </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>image</em>&nbsp;</td><td>Input image pointer containing "n" unsigned 8-bit pixels </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Size of image in pixels </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>accumulate</em>&nbsp;</td><td>Control to add or subtract from the running histogram. This control is only defined for the values 1 and -1 for ADD and SUBTRACT respectively </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t_hist</em>&nbsp;</td><td>Scratch buffer for temporary histogram storage (SIZE: 2^(img_bits+2)) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hist</em>&nbsp;</td><td>Running histogram bins (SIZE: 2^img_bits) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>img_bits</em>&nbsp;</td><td>Number of valid data bits per pixel</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Algorithm:</b></dt><dd>This code operates on four interleaved histogram bins. The loop is divided into two halves: The "even" half operates on the even-numbered double-words from the input image, and the "odd" half operates on odd double-words. Each half processes four pixels at a time, and both halves operate on the same four sets of histogram bins. This introduces a memory dependency on the histogram bins which ordinarily would degrade performance. To break the memory depenencies, the two halves forward their results to each other via the register file, bypassing memory. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>Exact memory access ordering obviates the need to predicate stores within the loop. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The algorithm is ordered as follows:<ol type=1>
<li>Load from histogram for even half</li><li>Store odd_bin to histogram for odd half (previous iteration)</li><li>IF data_even == previous data_odd THEN increment even_bin by 2 ELSE increment even_bin by 1, forward to odd</li><li>Load from histogram for odd half (current iteration)</li><li>Store even_bin to histogram for even half</li><li>IF data_odd == previous data_even THEN increment odd_bin by 2 ELSE increment odd_bin by 1, forward to even</li><li>Repeat from 1 </li></ol>
</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>With this particular ordering, forwarding is necessary between the even and odd halves when pixels in adjacent halves fall in the same bin. The store is never predicated and occurs speculatively as it will be overwritten by the next value containing the extra forwarded value. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The four scratch histograms are interleaved with each bin spaced four half words apart and each histogram starting in a different memory bank. This allows the four histogram accesses to proceed in any order without worrying about bank conflicts. The diagram below illustrates this: (addresses are halfword offsets) <div class="fragment"><pre class="fragment">
         0       1       2       3       4       5       6   ...        
     | hst 0 | hst 1 | hst 2 | hst 3 | hst 0 | hst 1 | ...   ...        
     | bin 0 | bin 0 | bin 0 | bin 0 | bin 1 | bin 1 | ...   ...        
   </pre></div> </dd></dl>
<dl class="user" compact><dt><b>Algorithm:</b></dt><dd>The natural C implementation has no restrictions. The optimized intrinsic C code has restrictions as noted in Assumptions below.</dd></dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The image and output histogram arrays do not overlap</li><li>The temporary array, t_hist, is initialized to zero for the first call to the routine (for "accumulate")</li><li>All arrays (image and histogram) are 64-bit aligned</li><li>The number of pixels is a non-zero multiple of 8.</li><li>The number of bits per pixel, "img_bits" is between 1 and 16 (inclusive)</li><li>The maximum count per bin is 32767</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible</li><li>This code is compatible with C64x+ processors</li><li>No bank conflicts should occur in this code</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See IMGLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2012, Texas Instruments Incorporated</small>
</body>
</html>
