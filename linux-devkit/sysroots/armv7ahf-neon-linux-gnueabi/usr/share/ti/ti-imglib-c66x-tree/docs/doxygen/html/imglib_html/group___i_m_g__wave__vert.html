<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>IMGLIB: IMG_wave_vert</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>IMG_wave_vert</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___i_m_g__wave__vert.html#g38d1ea58fd4e7e5e96e64cdbc9649d69">IMG_wave_vert</a> (const short *restrict *restrict in_data, const short *restrict qmf, const short *restrict mqmf, short *restrict out_ldata, short *restrict out_hdata, int cols)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g38d1ea58fd4e7e5e96e64cdbc9649d69"></a><!-- doxytag: member="c66/IMG_wave_vert.h::IMG_wave_vert" ref="g38d1ea58fd4e7e5e96e64cdbc9649d69" args="(const short *restrict *restrict in_data, const short *restrict qmf, const short *restrict mqmf, short *restrict out_ldata, short *restrict out_hdata, int cols)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void IMG_wave_vert           </td>
          <td>(</td>
          <td class="paramtype">const short *restrict *restrict&nbsp;</td>
          <td class="paramname"> <em>in_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *restrict&nbsp;</td>
          <td class="paramname"> <em>qmf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const short *restrict&nbsp;</td>
          <td class="paramname"> <em>mqmf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *restrict&nbsp;</td>
          <td class="paramname"> <em>out_ldata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short *restrict&nbsp;</td>
          <td class="paramname"> <em>out_hdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cols</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>The benchmark performs the vertical pass of 2D wavelet transform It performs a vertical filter on 8 rows which are pointed to by the pointers contained in an array of pointers. It produces two lines worth of output, one being the low-pass and the other being the high pass result. Instead of performing a transpose on the column and re-using the wave_horz kernel, the vertical filter is traversed over the entire width of the line and the low pass and high pass filtering kernels are performed together. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>This implies that the low-pass and highpass filters be overlapped in execution so that the input data array may be loaded once and both filters can be exceuted in parallel. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in_data</em>&nbsp;</td><td>Array of (8) row pointers </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>qmf</em>&nbsp;</td><td>Low pass QMF filter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mqmf</em>&nbsp;</td><td>High pass QMF filter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_ldata</em>&nbsp;</td><td>Low pass output data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>out_hdata</em>&nbsp;</td><td>High pass output data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cols</em>&nbsp;</td><td>Length of rows to process</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Algorithm:</b></dt><dd>The inner loop that advances along each filter tap is totally optimized by unrolling. Double-word loads are performed, and paired multiplies are used to perform four iterations of low-pass filter in parallel. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>For the high-pass kernel, the same loop is reused, in order to save codesize. This is done by loading the filter coefficients in a special order. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The kernels assume that the number of filter taps is exactly 8. In addition data that is loaded for producing out_ldata[0] and out_hdata[0] is not identical. The data loaded for producing out_hdata[0] produces results at the location <div class="fragment"><pre class="fragment">
            out_lstart = o_im + ((rows &gt;&gt; 1) - 3) * cols                 
            out_hstart = o_im +  (rows &gt;&gt; 1) * cols                       
                                                                        
   </pre></div></dd></dl>
Where o_im is start of output image, rows is the number of rows in the input image, and cols is the number of columns in the output image. <dl class="user" compact><dt><b></b></dt><dd>The following table illustrates how ylptr and yhptr need to be updated at the start of each call to this function: <div class="fragment"><pre class="fragment">
        Call#        out_ldata                  out_hdata                
          1          out_lstart                 out_hstart               
          2          out_lstart + cols          out_hstart + cols        
          3          out_lstart + 2*cols        out_hstart + 2*cols      
                                                                        
   </pre></div></dd></dl>
At this point ylptr wraps around to become o_im, while yhptr proceeds as usual: <div class="fragment"><pre class="fragment">
          4          o_im                       out_hstart + 3*cols      

   </pre></div><p>
In addition the kernel accepts a pointer to an array of pointers for each input line so that a working buffer of 10 lines can be used to effectively mix DMA's and processing as illustrated below: <div class="fragment"><pre class="fragment">
        ihptr                        LINE BUFFER                         
        ptr0   ----&gt;|-------------------------------------------------|  
        ptr1   ----&gt;|-------------------------------------------------|  
        ...                                                              
        ptr7   ----&gt;|-------------------------------------------------|  
   </pre></div><p>
At the start of the kernel 8 input lines are filled to the first 8 lines and processing begins. In the background the next two lines are fetched. The pointers are moved up by 2 namely ptr[i] = ptr[i+2] and the last two lines now point to lines 9 and 10 and processing starts again. In the background the next two lines are brought in the first two lines of the line buffer. Pointers move up again by 2 but now the last two pointers to line 0 and 1. This pattern then repeats. <dl class="user" compact><dt><b></b></dt><dd>The first line to begin filtering is always obtained from ptr[0], the next from ptr[1] and so on.</dd></dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The input image dimensions (rows and cols) are assumed to be powers of 2</li><li>The input filters qmf and mqmf are assumed to be word aligned and have exactly 8 taps.</li><li>The output data and input data on any line is assumed to be double-word aligned.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is a LITTLE ENDIAN implementation</li><li>In order to eliminate bank conflicts succesive lines in the line buffer or the pointers to these lines are seperated by exactly two banks (one word) so that loads to any succesive lines may be parallelized together</li><li>This code is compatible with C66x processors</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See IMGLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2012, Texas Instruments Incorporated</small>
</body>
</html>
