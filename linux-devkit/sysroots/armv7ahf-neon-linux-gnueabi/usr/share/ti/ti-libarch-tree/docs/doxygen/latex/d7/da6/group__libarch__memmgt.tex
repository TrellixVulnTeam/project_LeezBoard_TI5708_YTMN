\hypertarget{group__libarch__memmgt}{}\section{Memory Management A\+P\+I}
\label{group__libarch__memmgt}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}}


Error return codes of memory management functions.  


\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structlib__memdscr__str}{lib\+\_\+memdscr\+\_\+str}
\begin{DoxyCompactList}\small\item\em Memory descriptor structure. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__libarch__memmgt_gacfa30c2c1e697da904265b91b9c60d2f}{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S}~(0)
\item 
\#define \hyperlink{group__libarch__memmgt_ga21728661e7141fcfd212ca8286a7947b}{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R}~(-\/1)
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct \hyperlink{structlib__memdscr__str}{lib\+\_\+memdscr\+\_\+str} \hyperlink{group__libarch__memmgt_ga933f44304562f9591104d57b7868ebc3}{lib\+\_\+memdscr\+\_\+t}
\begin{DoxyCompactList}\small\item\em Memory descriptor structure. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \{ \\*
\hyperlink{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba98a90dd78f7e0d087e7d9c66505011c7}{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+V\+F\+A\+S\+T} = 0, 
\hyperlink{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba0554f0354c84251e347c0ee79ffe046d}{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+F\+A\+S\+T}, 
\hyperlink{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55bab6e0c7570cd8f2ada826e36d607d8abb}{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+M\+E\+D}, 
\hyperlink{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55badc4290cb2bdcc915f3156f39ce3ea361}{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+S\+L\+O\+W}, 
\\*
\hyperlink{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba5e2798bb86ffcd081fbd1a7fad3571a2}{L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+M\+E\+D}, 
\hyperlink{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba106f7b37f3b11574158123d265359eeb}{L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+S\+L\+O\+W}, 
\hyperlink{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba1cb4f966271cb92f79ba8229136f3a70}{L\+I\+B\+\_\+\+M\+E\+M\+T\+Y\+P\+E\+\_\+\+N}
 \}
\begin{DoxyCompactList}\small\item\em Memory types in terms of speed and volatility. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{group__libarch__memmgt_gaeeb7c8294fcd4640e4eaf7a741397032}{lib\+\_\+smem\+\_\+vinit} (void $\ast$handle, void $\ast$base, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+vinit performs necessary initialization for the very fast scratch heap memory allocation. \end{DoxyCompactList}\item 
int \hyperlink{group__libarch__memmgt_gadd591cf0185afae77c89e62a35af6395}{lib\+\_\+smem\+\_\+finit} (void $\ast$handle, void $\ast$base, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+finit performs necessary initialization for the fast scratch heap memory allocation. \end{DoxyCompactList}\item 
int \hyperlink{group__libarch__memmgt_ga991a1c6d4b40f4b4750c7fd1f8aa73f6}{lib\+\_\+smem\+\_\+minit} (void $\ast$handle, void $\ast$base, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+minit performs necessary initialization for the medium speed scratch heap memory allocation. \end{DoxyCompactList}\item 
int \hyperlink{group__libarch__memmgt_ga1dd9ae589bdfe68ced145885ea4c4789}{lib\+\_\+smem\+\_\+sinit} (void $\ast$handle, void $\ast$base, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+sinit performs necessary initialization for the slow scratch heap memory allocation. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{group__libarch__memmgt_ga24093174e441c683650863236dcb9806}{lib\+\_\+smem\+\_\+valloc} (void $\ast$handle, size\+\_\+t size, size\+\_\+t align)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+valloc allocates a memory block from the very fast scratch heap. It will also align the allocated memory block as requested. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{group__libarch__memmgt_ga51d763b1f89ef58e83cb9e4bc7546ba8}{lib\+\_\+smem\+\_\+falloc} (void $\ast$handle, size\+\_\+t size, size\+\_\+t align)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+falloc allocates a memory block from the fast scratch heap. It will also align the address of the allocated memory block as requested. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{group__libarch__memmgt_gaac0047f2fe5ce1dfad45fc0333d906dc}{lib\+\_\+smem\+\_\+malloc} (void $\ast$handle, size\+\_\+t size, size\+\_\+t align)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+malloc allocates a memory block from the medium speed scratch heap. It will also align the address of the allocated memory block as requested. \end{DoxyCompactList}\item 
void $\ast$ \hyperlink{group__libarch__memmgt_ga08b73e8bf61fb50e20e08f7df4de636b}{lib\+\_\+smem\+\_\+salloc} (void $\ast$handle, size\+\_\+t size, size\+\_\+t align)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+salloc allocates a memory block from the slow scratch heap. It will also align the address of the allocated memory block as requested. \end{DoxyCompactList}\item 
int \hyperlink{group__libarch__memmgt_ga65c30f7a20c6e359df9d73db0c9078c1}{lib\+\_\+smem\+\_\+vreset} (void $\ast$handle)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+vreset resets the very fast scratch heap and destroys all allocated memory blocks in it. \end{DoxyCompactList}\item 
int \hyperlink{group__libarch__memmgt_ga18470bba549f0d9c4a6d98a1f615b8c2}{lib\+\_\+smem\+\_\+freset} (void $\ast$handle)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+freset resets the fast scratch heap and destroys all allocated memory blocks in it. \end{DoxyCompactList}\item 
int \hyperlink{group__libarch__memmgt_ga38dbf46a5af66e691ba20ffb61f9932e}{lib\+\_\+smem\+\_\+mreset} (void $\ast$handle)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+mreset resets the medium speed scratch heap and destroys all allocated memory blocks in it. \end{DoxyCompactList}\item 
int \hyperlink{group__libarch__memmgt_gaa3fb30e824c80ec62d4e7847f292108f}{lib\+\_\+smem\+\_\+sreset} (void $\ast$handle)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+smem\+\_\+mreset resets the slow scratch heap and destroys all allocated memory blocks in it. \end{DoxyCompactList}\item 
static void $\ast$ \hyperlink{group__libarch__memmgt_gaeae499cb566d6411b938107d3ffeb144}{lib\+\_\+pmem\+\_\+malloc} (void $\ast$handle, size\+\_\+t size, size\+\_\+t align)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+pmem\+\_\+malloc allocates a memory block from the medium speed permanent heap. It will also align the address of the allocated memory block as requested. \end{DoxyCompactList}\item 
static void $\ast$ \hyperlink{group__libarch__memmgt_ga306a1aa220281f0b6d79b12928bfeff8}{lib\+\_\+pmem\+\_\+salloc} (void $\ast$handle, size\+\_\+t size, size\+\_\+t align)
\begin{DoxyCompactList}\small\item\em Function lib\+\_\+pmem\+\_\+salloc allocates a memory block from the slow permanent heap. It will also align the address of the allocated memory block as requested. \end{DoxyCompactList}\item 
static void \hyperlink{group__libarch__memmgt_gafeda2ec3f28d9ebb87a8adcecbb0f414}{lib\+\_\+pmem\+\_\+mfree} (void $\ast$handle, void $\ast$mem\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Refer to \hyperlink{lib__memmgt_8h}{lib\+\_\+memmgt.\+h} for detailed documentation. \end{DoxyCompactList}\item 
static void \hyperlink{group__libarch__memmgt_gab12e1d41b3d71633c9ab2d8818510f63}{lib\+\_\+pmem\+\_\+sfree} (void $\ast$handle, void $\ast$mem\+\_\+ptr)
\begin{DoxyCompactList}\small\item\em Refer to \hyperlink{lib__memmgt_8h}{lib\+\_\+memmgt.\+h} for detailed documentation. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Error return codes of memory management functions. 



\subsection{Macro Definition Documentation}
\hypertarget{group__libarch__memmgt_ga21728661e7141fcfd212ca8286a7947b}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R@{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R}}
\index{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R@{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R~(-\/1)}\label{group__libarch__memmgt_ga21728661e7141fcfd212ca8286a7947b}
Failure. \hypertarget{group__libarch__memmgt_gacfa30c2c1e697da904265b91b9c60d2f}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S@{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S}}
\index{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S@{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S~(0)}\label{group__libarch__memmgt_gacfa30c2c1e697da904265b91b9c60d2f}
Success. No error. 

\subsection{Typedef Documentation}
\hypertarget{group__libarch__memmgt_ga933f44304562f9591104d57b7868ebc3}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+memdscr\+\_\+t@{lib\+\_\+memdscr\+\_\+t}}
\index{lib\+\_\+memdscr\+\_\+t@{lib\+\_\+memdscr\+\_\+t}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+memdscr\+\_\+t}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf lib\+\_\+memdscr\+\_\+str}  {\bf lib\+\_\+memdscr\+\_\+t}}\label{group__libarch__memmgt_ga933f44304562f9591104d57b7868ebc3}


Memory descriptor structure. 

\begin{DoxyRemark}{Remarks}
The user M\+U\+S\+T define an array of memory descriptors and pass the address of the array to the heap initialization and allocation routines. For example, the memory descriptor array may be defined as\+: \begin{DoxyVerb}    lib_memdscr_t libxyz_smem_med;
    lib_memdscr_t libxyz_smem_fast;
    lib_memdscr_t libxyz_smem_vfast;
    
    lib_memdscr_t * libxyz_memdscr_tab[LIB_MEMTYPE_N] = {
      &libxyz_smem_vfast,
      &libxyz_smem_fast,
      &libxyz_smem_med,
      NULL                // scratch slow memory is not used by libxyz 
    };\end{DoxyVerb}
 
\end{DoxyRemark}


\subsection{Enumeration Type Documentation}
\hypertarget{group__libarch__memmgt_ga06fc87d81c62e9abb8790b6e5713c55b}{}\subsubsection[{anonymous enum}]{\setlength{\rightskip}{0pt plus 5cm}anonymous enum}\label{group__libarch__memmgt_ga06fc87d81c62e9abb8790b6e5713c55b}


Memory types in terms of speed and volatility. 

\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+V\+F\+A\+S\+T@{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+V\+F\+A\+S\+T}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+V\+F\+A\+S\+T@{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+V\+F\+A\+S\+T}}\item[{\em 
\hypertarget{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba98a90dd78f7e0d087e7d9c66505011c7}{}L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+V\+F\+A\+S\+T\label{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba98a90dd78f7e0d087e7d9c66505011c7}
}]Scratch memory, very fast \index{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+F\+A\+S\+T@{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+F\+A\+S\+T}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+F\+A\+S\+T@{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+F\+A\+S\+T}}\item[{\em 
\hypertarget{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba0554f0354c84251e347c0ee79ffe046d}{}L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+F\+A\+S\+T\label{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba0554f0354c84251e347c0ee79ffe046d}
}]Scratch memory, fast \index{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+M\+E\+D@{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+M\+E\+D}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+M\+E\+D@{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+M\+E\+D}}\item[{\em 
\hypertarget{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55bab6e0c7570cd8f2ada826e36d607d8abb}{}L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+M\+E\+D\label{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55bab6e0c7570cd8f2ada826e36d607d8abb}
}]Scratch memory, medium speed \index{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+S\+L\+O\+W@{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+S\+L\+O\+W}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+S\+L\+O\+W@{L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+S\+L\+O\+W}}\item[{\em 
\hypertarget{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55badc4290cb2bdcc915f3156f39ce3ea361}{}L\+I\+B\+\_\+\+S\+M\+E\+M\+\_\+\+S\+L\+O\+W\label{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55badc4290cb2bdcc915f3156f39ce3ea361}
}]Scratch memory, slow \index{L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+M\+E\+D@{L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+M\+E\+D}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+M\+E\+D@{L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+M\+E\+D}}\item[{\em 
\hypertarget{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba5e2798bb86ffcd081fbd1a7fad3571a2}{}L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+M\+E\+D\label{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba5e2798bb86ffcd081fbd1a7fad3571a2}
}]Permanent memory, medium speed \index{L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+S\+L\+O\+W@{L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+S\+L\+O\+W}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+S\+L\+O\+W@{L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+S\+L\+O\+W}}\item[{\em 
\hypertarget{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba106f7b37f3b11574158123d265359eeb}{}L\+I\+B\+\_\+\+P\+M\+E\+M\+\_\+\+S\+L\+O\+W\label{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba106f7b37f3b11574158123d265359eeb}
}]Permanent memory, slow \index{L\+I\+B\+\_\+\+M\+E\+M\+T\+Y\+P\+E\+\_\+\+N@{L\+I\+B\+\_\+\+M\+E\+M\+T\+Y\+P\+E\+\_\+\+N}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!L\+I\+B\+\_\+\+M\+E\+M\+T\+Y\+P\+E\+\_\+\+N@{L\+I\+B\+\_\+\+M\+E\+M\+T\+Y\+P\+E\+\_\+\+N}}\item[{\em 
\hypertarget{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba1cb4f966271cb92f79ba8229136f3a70}{}L\+I\+B\+\_\+\+M\+E\+M\+T\+Y\+P\+E\+\_\+\+N\label{group__libarch__memmgt_gga06fc87d81c62e9abb8790b6e5713c55ba1cb4f966271cb92f79ba8229136f3a70}
}]Total number of types \end{description}
\end{Desc}


\subsection{Function Documentation}
\hypertarget{group__libarch__memmgt_gaeae499cb566d6411b938107d3ffeb144}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+pmem\+\_\+malloc@{lib\+\_\+pmem\+\_\+malloc}}
\index{lib\+\_\+pmem\+\_\+malloc@{lib\+\_\+pmem\+\_\+malloc}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+pmem\+\_\+malloc}]{\setlength{\rightskip}{0pt plus 5cm}static void$\ast$ lib\+\_\+pmem\+\_\+malloc (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{size\+\_\+t}]{size, }
\item[{size\+\_\+t}]{align}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{group__libarch__memmgt_gaeae499cb566d6411b938107d3ffeb144}


Function lib\+\_\+pmem\+\_\+malloc allocates a memory block from the medium speed permanent heap. It will also align the address of the allocated memory block as requested. 

\begin{DoxyRemark}{Remarks}
In this release, this function simply calls run time support library function memalign().
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton \\
\hline
\mbox{\tt in}  & {\em size} & Size of memory block to be allocated \\
\hline
\mbox{\tt in}  & {\em align} & Alignment. The address of the allocated memory block will be aligned to 2$^\wedge$align bytes.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Non-\/\+N\+U\+L\+L} & Address of the allocated memory block \\
\hline
{\em N\+U\+L\+L} & Failure to allocate memory \\
\hline
\end{DoxyRetVals}
\hypertarget{group__libarch__memmgt_gafeda2ec3f28d9ebb87a8adcecbb0f414}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+pmem\+\_\+mfree@{lib\+\_\+pmem\+\_\+mfree}}
\index{lib\+\_\+pmem\+\_\+mfree@{lib\+\_\+pmem\+\_\+mfree}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+pmem\+\_\+mfree}]{\setlength{\rightskip}{0pt plus 5cm}static void lib\+\_\+pmem\+\_\+mfree (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{void $\ast$}]{mem\+\_\+ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{group__libarch__memmgt_gafeda2ec3f28d9ebb87a8adcecbb0f414}


Refer to \hyperlink{lib__memmgt_8h}{lib\+\_\+memmgt.\+h} for detailed documentation. 

\begin{DoxyRemark}{Remarks}
In this release, this function simply calls run time support library function free().
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton \\
\hline
\mbox{\tt in}  & {\em mem\+\_\+ptr} & Pointer to the memory to be freed \\
\hline
\end{DoxyParams}
\hypertarget{group__libarch__memmgt_ga306a1aa220281f0b6d79b12928bfeff8}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+pmem\+\_\+salloc@{lib\+\_\+pmem\+\_\+salloc}}
\index{lib\+\_\+pmem\+\_\+salloc@{lib\+\_\+pmem\+\_\+salloc}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+pmem\+\_\+salloc}]{\setlength{\rightskip}{0pt plus 5cm}static void$\ast$ lib\+\_\+pmem\+\_\+salloc (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{size\+\_\+t}]{size, }
\item[{size\+\_\+t}]{align}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{group__libarch__memmgt_ga306a1aa220281f0b6d79b12928bfeff8}


Function lib\+\_\+pmem\+\_\+salloc allocates a memory block from the slow permanent heap. It will also align the address of the allocated memory block as requested. 

\begin{DoxyRemark}{Remarks}
In this release, this function simply calls run time support library function memalign().
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton \\
\hline
\mbox{\tt in}  & {\em size} & Size of memory block to be allocated \\
\hline
\mbox{\tt in}  & {\em align} & Alignment. The address of the allocated memory block will be aligned to 2$^\wedge$align bytes.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Non-\/\+N\+U\+L\+L} & Address of the allocated memory block \\
\hline
{\em N\+U\+L\+L} & Failure to allocate memory \\
\hline
\end{DoxyRetVals}
\hypertarget{group__libarch__memmgt_gab12e1d41b3d71633c9ab2d8818510f63}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+pmem\+\_\+sfree@{lib\+\_\+pmem\+\_\+sfree}}
\index{lib\+\_\+pmem\+\_\+sfree@{lib\+\_\+pmem\+\_\+sfree}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+pmem\+\_\+sfree}]{\setlength{\rightskip}{0pt plus 5cm}static void lib\+\_\+pmem\+\_\+sfree (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{void $\ast$}]{mem\+\_\+ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{group__libarch__memmgt_gab12e1d41b3d71633c9ab2d8818510f63}


Refer to \hyperlink{lib__memmgt_8h}{lib\+\_\+memmgt.\+h} for detailed documentation. 

\begin{DoxyRemark}{Remarks}
In this release, this function simply calls run time support library function free().
\end{DoxyRemark}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton \\
\hline
\mbox{\tt in}  & {\em mem\+\_\+ptr} & Pointer to the memory to be freed \\
\hline
\end{DoxyParams}
\hypertarget{group__libarch__memmgt_ga51d763b1f89ef58e83cb9e4bc7546ba8}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+falloc@{lib\+\_\+smem\+\_\+falloc}}
\index{lib\+\_\+smem\+\_\+falloc@{lib\+\_\+smem\+\_\+falloc}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+falloc}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ lib\+\_\+smem\+\_\+falloc (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{size\+\_\+t}]{size, }
\item[{size\+\_\+t}]{align}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_ga51d763b1f89ef58e83cb9e4bc7546ba8}


Function lib\+\_\+smem\+\_\+falloc allocates a memory block from the fast scratch heap. It will also align the address of the allocated memory block as requested. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton \\
\hline
\mbox{\tt in}  & {\em size} & Size of memory block to be allocated \\
\hline
\mbox{\tt in}  & {\em align} & Alignment. The address of the allocated memory block will be aligned to 2$^\wedge$align bytes.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Non-\/\+N\+U\+L\+L} & Address of the allocated memory block \\
\hline
{\em N\+U\+L\+L} & Failure to allocate memory\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
Function lib\+\_\+smem\+\_\+finit must be called first before this function can be used to allocate memory.
\end{DoxyPrecond}
Function lib\+\_\+smem\+\_\+falloc allocates a memory block from the fast scratch heap. It will also align the address of the allocated memory block as requested. \hypertarget{group__libarch__memmgt_gadd591cf0185afae77c89e62a35af6395}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+finit@{lib\+\_\+smem\+\_\+finit}}
\index{lib\+\_\+smem\+\_\+finit@{lib\+\_\+smem\+\_\+finit}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+finit}]{\setlength{\rightskip}{0pt plus 5cm}int lib\+\_\+smem\+\_\+finit (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{void $\ast$}]{base, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_gadd591cf0185afae77c89e62a35af6395}


Function lib\+\_\+smem\+\_\+finit performs necessary initialization for the fast scratch heap memory allocation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array \\
\hline
\mbox{\tt in}  & {\em base} & Base address of the memory to be used as fast scratch \\
\hline
\mbox{\tt in}  & {\em size} & Size of the memory in bytes\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S} & Success. No error. \\
\hline
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R} & Failure.\\
\hline
\end{DoxyRetVals}
Function lib\+\_\+smem\+\_\+finit performs necessary initialization for the fast scratch heap memory allocation. \hypertarget{group__libarch__memmgt_ga18470bba549f0d9c4a6d98a1f615b8c2}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+freset@{lib\+\_\+smem\+\_\+freset}}
\index{lib\+\_\+smem\+\_\+freset@{lib\+\_\+smem\+\_\+freset}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+freset}]{\setlength{\rightskip}{0pt plus 5cm}int lib\+\_\+smem\+\_\+freset (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_ga18470bba549f0d9c4a6d98a1f615b8c2}


Function lib\+\_\+smem\+\_\+freset resets the fast scratch heap and destroys all allocated memory blocks in it. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S} & Success. No error. \\
\hline
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R} & Failure.\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
Function lib\+\_\+smem\+\_\+finit must be called first before this function can be called.
\end{DoxyPrecond}
Function lib\+\_\+smem\+\_\+freset resets the fast scratch heap and destroys all allocated memory blocks in it. \hypertarget{group__libarch__memmgt_gaac0047f2fe5ce1dfad45fc0333d906dc}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+malloc@{lib\+\_\+smem\+\_\+malloc}}
\index{lib\+\_\+smem\+\_\+malloc@{lib\+\_\+smem\+\_\+malloc}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+malloc}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ lib\+\_\+smem\+\_\+malloc (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{size\+\_\+t}]{size, }
\item[{size\+\_\+t}]{align}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_gaac0047f2fe5ce1dfad45fc0333d906dc}


Function lib\+\_\+smem\+\_\+malloc allocates a memory block from the medium speed scratch heap. It will also align the address of the allocated memory block as requested. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton \\
\hline
\mbox{\tt in}  & {\em size} & Size of memory block to be allocated \\
\hline
\mbox{\tt in}  & {\em align} & Alignment. The address of the allocated memory block will be aligned to 2$^\wedge$align bytes.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Non-\/\+N\+U\+L\+L} & Address of the allocated memory block \\
\hline
{\em N\+U\+L\+L} & Failure to allocate memory\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
Function lib\+\_\+smem\+\_\+minit must be called first before this function can be used to allocate memory.
\end{DoxyPrecond}
Function lib\+\_\+smem\+\_\+malloc allocates a memory block from the medium speed scratch heap. It will also align the address of the allocated memory block as requested. \hypertarget{group__libarch__memmgt_ga991a1c6d4b40f4b4750c7fd1f8aa73f6}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+minit@{lib\+\_\+smem\+\_\+minit}}
\index{lib\+\_\+smem\+\_\+minit@{lib\+\_\+smem\+\_\+minit}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+minit}]{\setlength{\rightskip}{0pt plus 5cm}int lib\+\_\+smem\+\_\+minit (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{void $\ast$}]{base, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_ga991a1c6d4b40f4b4750c7fd1f8aa73f6}


Function lib\+\_\+smem\+\_\+minit performs necessary initialization for the medium speed scratch heap memory allocation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array \\
\hline
\mbox{\tt in}  & {\em base} & Base address of the memory to be used as medium scratch \\
\hline
\mbox{\tt in}  & {\em size} & Size of the memory in bytes\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S} & Success. No error. \\
\hline
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R} & Failure.\\
\hline
\end{DoxyRetVals}
Function lib\+\_\+smem\+\_\+minit performs necessary initialization for the medium speed scratch heap memory allocation. \hypertarget{group__libarch__memmgt_ga38dbf46a5af66e691ba20ffb61f9932e}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+mreset@{lib\+\_\+smem\+\_\+mreset}}
\index{lib\+\_\+smem\+\_\+mreset@{lib\+\_\+smem\+\_\+mreset}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+mreset}]{\setlength{\rightskip}{0pt plus 5cm}int lib\+\_\+smem\+\_\+mreset (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_ga38dbf46a5af66e691ba20ffb61f9932e}


Function lib\+\_\+smem\+\_\+mreset resets the medium speed scratch heap and destroys all allocated memory blocks in it. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S} & Success. No error. \\
\hline
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R} & Failure.\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
Function lib\+\_\+smem\+\_\+minit must be called first before this function can be called.
\end{DoxyPrecond}
Function lib\+\_\+smem\+\_\+mreset resets the medium speed scratch heap and destroys all allocated memory blocks in it. \hypertarget{group__libarch__memmgt_ga08b73e8bf61fb50e20e08f7df4de636b}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+salloc@{lib\+\_\+smem\+\_\+salloc}}
\index{lib\+\_\+smem\+\_\+salloc@{lib\+\_\+smem\+\_\+salloc}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+salloc}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ lib\+\_\+smem\+\_\+salloc (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{size\+\_\+t}]{size, }
\item[{size\+\_\+t}]{align}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_ga08b73e8bf61fb50e20e08f7df4de636b}


Function lib\+\_\+smem\+\_\+salloc allocates a memory block from the slow scratch heap. It will also align the address of the allocated memory block as requested. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton \\
\hline
\mbox{\tt in}  & {\em size} & Size of memory block to be allocated \\
\hline
\mbox{\tt in}  & {\em align} & Alignment. The address of the allocated memory block will be aligned to 2$^\wedge$align bytes.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Non-\/\+N\+U\+L\+L} & Address of the allocated memory block \\
\hline
{\em N\+U\+L\+L} & Failure to allocate memory\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
Function lib\+\_\+smem\+\_\+sinit must be called first before this function can be used to allocate memory.
\end{DoxyPrecond}
Function lib\+\_\+smem\+\_\+salloc allocates a memory block from the slow scratch heap. It will also align the address of the allocated memory block as requested. \hypertarget{group__libarch__memmgt_ga1dd9ae589bdfe68ced145885ea4c4789}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+sinit@{lib\+\_\+smem\+\_\+sinit}}
\index{lib\+\_\+smem\+\_\+sinit@{lib\+\_\+smem\+\_\+sinit}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+sinit}]{\setlength{\rightskip}{0pt plus 5cm}int lib\+\_\+smem\+\_\+sinit (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{void $\ast$}]{base, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_ga1dd9ae589bdfe68ced145885ea4c4789}


Function lib\+\_\+smem\+\_\+sinit performs necessary initialization for the slow scratch heap memory allocation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array \\
\hline
\mbox{\tt in}  & {\em base} & Base address of the memory to be used as slow scratch \\
\hline
\mbox{\tt in}  & {\em size} & Size of the memory in bytes\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S} & Success. No error. \\
\hline
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R} & Failure.\\
\hline
\end{DoxyRetVals}
Function lib\+\_\+smem\+\_\+sinit performs necessary initialization for the slow scratch heap memory allocation. \hypertarget{group__libarch__memmgt_gaa3fb30e824c80ec62d4e7847f292108f}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+sreset@{lib\+\_\+smem\+\_\+sreset}}
\index{lib\+\_\+smem\+\_\+sreset@{lib\+\_\+smem\+\_\+sreset}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+sreset}]{\setlength{\rightskip}{0pt plus 5cm}int lib\+\_\+smem\+\_\+sreset (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_gaa3fb30e824c80ec62d4e7847f292108f}


Function lib\+\_\+smem\+\_\+mreset resets the slow scratch heap and destroys all allocated memory blocks in it. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S} & Success. No error. \\
\hline
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R} & Failure.\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
Function lib\+\_\+smem\+\_\+sinit must be called first before this function can be called.
\end{DoxyPrecond}
Function lib\+\_\+smem\+\_\+mreset resets the slow scratch heap and destroys all allocated memory blocks in it. \hypertarget{group__libarch__memmgt_ga24093174e441c683650863236dcb9806}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+valloc@{lib\+\_\+smem\+\_\+valloc}}
\index{lib\+\_\+smem\+\_\+valloc@{lib\+\_\+smem\+\_\+valloc}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+valloc}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ lib\+\_\+smem\+\_\+valloc (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{size\+\_\+t}]{size, }
\item[{size\+\_\+t}]{align}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_ga24093174e441c683650863236dcb9806}


Function lib\+\_\+smem\+\_\+valloc allocates a memory block from the very fast scratch heap. It will also align the allocated memory block as requested. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array \\
\hline
\mbox{\tt in}  & {\em size} & Size of memory block to be allocated \\
\hline
\mbox{\tt in}  & {\em align} & Alignment. The address of the allocated memory block will be aligned to 2$^\wedge$align bytes.\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em Non-\/\+N\+U\+L\+L} & Address of the allocated memory block \\
\hline
{\em N\+U\+L\+L} & Failure to allocate memory\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
Function lib\+\_\+smem\+\_\+vinit must be called first before this function can be used to allocate memory.
\end{DoxyPrecond}
Function lib\+\_\+smem\+\_\+valloc allocates a memory block from the very fast scratch heap. It will also align the allocated memory block as requested. \hypertarget{group__libarch__memmgt_gaeeb7c8294fcd4640e4eaf7a741397032}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+vinit@{lib\+\_\+smem\+\_\+vinit}}
\index{lib\+\_\+smem\+\_\+vinit@{lib\+\_\+smem\+\_\+vinit}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+vinit}]{\setlength{\rightskip}{0pt plus 5cm}int lib\+\_\+smem\+\_\+vinit (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle, }
\item[{void $\ast$}]{base, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_gaeeb7c8294fcd4640e4eaf7a741397032}


Function lib\+\_\+smem\+\_\+vinit performs necessary initialization for the very fast scratch heap memory allocation. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array \\
\hline
\mbox{\tt in}  & {\em base} & Base address of the memory to be used as very fast scratch \\
\hline
\mbox{\tt in}  & {\em size} & Size of the memory in bytes\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S} & Success. No error. \\
\hline
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R} & Failure.\\
\hline
\end{DoxyRetVals}
Function lib\+\_\+smem\+\_\+vinit performs necessary initialization for the very fast scratch heap memory allocation. \hypertarget{group__libarch__memmgt_ga65c30f7a20c6e359df9d73db0c9078c1}{}\index{Memory Management A\+P\+I@{Memory Management A\+P\+I}!lib\+\_\+smem\+\_\+vreset@{lib\+\_\+smem\+\_\+vreset}}
\index{lib\+\_\+smem\+\_\+vreset@{lib\+\_\+smem\+\_\+vreset}!Memory Management A\+P\+I@{Memory Management A\+P\+I}}
\subsubsection[{lib\+\_\+smem\+\_\+vreset}]{\setlength{\rightskip}{0pt plus 5cm}int lib\+\_\+smem\+\_\+vreset (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{handle}
\end{DoxyParamCaption}
)}\label{group__libarch__memmgt_ga65c30f7a20c6e359df9d73db0c9078c1}


Function lib\+\_\+smem\+\_\+vreset resets the very fast scratch heap and destroys all allocated memory blocks in it. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handle} & Pointer to the memory descriptor array defined by the library using this funciton\\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+S\+U\+C\+C\+E\+S\+S} & Success. No error. \\
\hline
{\em L\+I\+B\+\_\+\+M\+E\+M\+M\+G\+T\+\_\+\+E\+R\+R\+O\+R} & Failure.\\
\hline
\end{DoxyRetVals}
\begin{DoxyPrecond}{Precondition}
Function lib\+\_\+smem\+\_\+vinit must be called first before this function can be called.
\end{DoxyPrecond}
Function lib\+\_\+smem\+\_\+vreset resets the very fast scratch heap and destroys all allocated memory blocks in it. 