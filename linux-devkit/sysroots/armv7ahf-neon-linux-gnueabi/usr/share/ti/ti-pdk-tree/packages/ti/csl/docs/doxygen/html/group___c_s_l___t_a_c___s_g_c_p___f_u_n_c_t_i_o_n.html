<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TAC2 SGCP Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TAC2 SGCP Functions<div class="ingroups"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___a_p_i.html">TAC2 SGCP</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga72b2de74dfe3ac9ad9d1e61c3924a2bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga72b2de74dfe3ac9ad9d1e61c3924a2bd">CSL_TAC_SGCP_enable</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga72b2de74dfe3ac9ad9d1e61c3924a2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2bf6c4657e883fa6652ee94a9485587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#gaa2bf6c4657e883fa6652ee94a9485587">CSL_TAC_SGCP_disable</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:gaa2bf6c4657e883fa6652ee94a9485587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8144ca8dc37d5342d67d885f5d43da53"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga8144ca8dc37d5342d67d885f5d43da53">CSL_TAC_SGCP_getActiveCycles</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga8144ca8dc37d5342d67d885f5d43da53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2ab901a9eccc36db8a971c1b95b2948"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#gae2ab901a9eccc36db8a971c1b95b2948">CSL_TAC_SGCP_getSequencerCycles</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:gae2ab901a9eccc36db8a971c1b95b2948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87347d9ab3a96d72b48e9bcc4d225efd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga87347d9ab3a96d72b48e9bcc4d225efd">CSL_TAC_SGCP_getReadTime</a> (<a class="el" href="struct_c_s_l___t_a_c___s_g_c_p___timestamp__req.html">CSL_TAC_SGCP_Timestamp_req</a> *timestamp)</td></tr>
<tr class="separator:ga87347d9ab3a96d72b48e9bcc4d225efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3cfdb87746a3b237a96b04e97004093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#gab3cfdb87746a3b237a96b04e97004093">CSL_TAC_SGCP_getCycleOverflowStatus</a> (Uint8 sgcpId, <a class="el" href="struct_c_s_l___t_a_c___s_g_c_p__cycle_overflow_status.html">CSL_TAC_SGCP_cycleOverflowStatus</a> *cycleOverflowStatus)</td></tr>
<tr class="separator:gab3cfdb87746a3b237a96b04e97004093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5738c18b769dd8c7da92a1f1cfb38e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga8e5738c18b769dd8c7da92a1f1cfb38e">CSL_TAC_SGCP_resetCycleOverflowStatus</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga8e5738c18b769dd8c7da92a1f1cfb38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1195c504e11e111b033368eb35fb165f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga1195c504e11e111b033368eb35fb165f">CSL_TAC_SGCP_getSymbolBuffMissStatus</a> (Uint8 sgcpId, <a class="el" href="struct_c_s_l___t_a_c___s_g_c_p__symbol_buff_miss_status.html">CSL_TAC_SGCP_symbolBuffMissStatus</a> *symBuffMissStatus)</td></tr>
<tr class="separator:ga1195c504e11e111b033368eb35fb165f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d14cc530ae9904f7b10bba671176ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga88d14cc530ae9904f7b10bba671176ce">CSL_TAC_SGCP_resetSymbolBuffMissStatus</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga88d14cc530ae9904f7b10bba671176ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54cfb8c5fce7908639ad80d71f1d7f17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga54cfb8c5fce7908639ad80d71f1d7f17">CSL_TAC_SGCP_getFIFOOverflowStatus</a> (Uint8 sgcpId, <a class="el" href="struct_c_s_l___t_a_c___s_g_c_p__fifo_overflow_status.html">CSL_TAC_SGCP_fifoOverflowStatus</a> *fifoOverflowStatus)</td></tr>
<tr class="separator:ga54cfb8c5fce7908639ad80d71f1d7f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf157670447228377573affc5ca943e76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#gaf157670447228377573affc5ca943e76">CSL_TAC_SGCP_resetFIFOOverflowStatus</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:gaf157670447228377573affc5ca943e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec8e9758ce2aa3435603eb1f23046ad"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga4ec8e9758ce2aa3435603eb1f23046ad">CSL_TAC_SGCP_getFetchQLevel</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga4ec8e9758ce2aa3435603eb1f23046ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga212816db3cae67da66ba6a2a74cbf6c7"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga212816db3cae67da66ba6a2a74cbf6c7">CSL_TAC_SGCP_getFetchQWatermark</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga212816db3cae67da66ba6a2a74cbf6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb3033f7749aedb6339e7042881426f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#gaddb3033f7749aedb6339e7042881426f">CSL_TAC_SGCP_resetFetchQueue</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:gaddb3033f7749aedb6339e7042881426f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f364f338099d1239ec2a465cb52a887"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga0f364f338099d1239ec2a465cb52a887">CSL_TAC_SGCP_getCPMQLevel</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga0f364f338099d1239ec2a465cb52a887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48aeb279b50f0e5085a9fc54e61e8110"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga48aeb279b50f0e5085a9fc54e61e8110">CSL_TAC_SGCP_getCPMQWatermark</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga48aeb279b50f0e5085a9fc54e61e8110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194862ca41dcb563e9c40ca7a34d3da8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga194862ca41dcb563e9c40ca7a34d3da8">CSL_TAC_SGCP_resetCPMQueue</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga194862ca41dcb563e9c40ca7a34d3da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1574d86bdf3594e4d604f93d671529ab"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga1574d86bdf3594e4d604f93d671529ab">CSL_TAC_SGCP_getWarningQLevel</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga1574d86bdf3594e4d604f93d671529ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a085b56cf30ad62ed7beae33aec9b61"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#ga0a085b56cf30ad62ed7beae33aec9b61">CSL_TAC_SGCP_getWarningQWatermark</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:ga0a085b56cf30ad62ed7beae33aec9b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafba0dedddf4ffafba95428b7d9596a03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_a_c___s_g_c_p___f_u_n_c_t_i_o_n.html#gafba0dedddf4ffafba95428b7d9596a03">CSL_TAC_SGCP_resetWarningQueue</a> (Uint8 sgcpId)</td></tr>
<tr class="separator:gafba0dedddf4ffafba95428b7d9596a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaa2bf6c4657e883fa6652ee94a9485587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_disable </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_disable</b> </p>
<p><b>Description</b> <br />
 This function disables a Spreader Group Co-Processor (SGCP) identified by <em>sgcpId</em>.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP to disable.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The SGCP Sequencer is disabled.</p>
<p><b>Writes</b> <br />
 SGCP_CFG_SGCP_SEQ_ENA_ENABLE=0</p>
<p><b>Example</b> </p><pre class="fragment">// Disable SGCP 0
CSL_TAC_SGCP_disable(0);

// Disable SGCP 1
CSL_TAC_SGCP_disable(1);
</pre> 
</div>
</div>
<a class="anchor" id="ga72b2de74dfe3ac9ad9d1e61c3924a2bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_enable </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_enable</b> </p>
<p><b>Description</b> <br />
 This function enables a Spreader Group Co-Processor (SGCP) identified by <em>sgcpId</em>.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP to enable.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The SGCP Sequencer is enabled.</p>
<p><b>Writes</b> <br />
 SGCP_CFG_SGCP_SEQ_ENA_ENABLE=1</p>
<p><b>Example</b> </p><pre class="fragment">// Enable SGCP 0
CSL_TAC_SGCP_enable(0);

// Enable SGCP 1
CSL_TAC_SGCP_enable(1);
</pre> 
</div>
</div>
<a class="anchor" id="ga8144ca8dc37d5342d67d885f5d43da53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 CSL_TAC_SGCP_getActiveCycles </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getActiveCycles</b> </p>
<p><b>Description</b> <br />
 This function returns the number of active cycles in the previous iteration.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP to get status from.
</pre><p><b> Return Value </b> <br />
 The number of active cycles</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_SGCP_SEQ_ACT_ACT_COUNT</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  actCycles;

// Get the Active cycles for SGCP 0
actCycles = CSL_TAC_SGCP_getActiveCycles(0);

// Get the Active cycles for SGCP 1
actCycles = CSL_TAC_SGCP_getActiveCycles(1);
</pre> 
</div>
</div>
<a class="anchor" id="ga0f364f338099d1239ec2a465cb52a887"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_TAC_SGCP_getCPMQLevel </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getCPMQLevel</b> </p>
<p><b>Description</b> <br />
 This function returns the Code Power Measurement Transaction Queue Current Level for a given SGCP ID.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP CPM queue current level to read.
</pre><p><b> Return Value </b> <br />
 The current value of the level</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_CTQ_CURR_LVL_CURR_LVL</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  level;

// Get the Queue Level for SGCP 0
level = CSL_TAC_SGCP_getCPMQLevel(0);
...

// Get the Queue Level for SGCP 1
level = CSL_TAC_SGCP_getCPMQLevel(1);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga48aeb279b50f0e5085a9fc54e61e8110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_TAC_SGCP_getCPMQWatermark </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getCPMQWatermark</b> </p>
<p><b>Description</b> <br />
 This function returns the Code Power Measurement Transaction Queue Water Mark for a given SGCP ID.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP CPM queue water mark to read.
</pre><p><b> Return Value </b> <br />
 The highest level of the queue.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Reading of this register resets the value to the current level.</p>
<p><b>Reads</b> <br />
 SGCP_CFG_CTQ_WTMK_LVL_WATERMARK</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  level;

// Get the Queue Level for SGCP 0
level = CSL_TAC_SGCP_getCPMQWatermark(0);
...

// Get the Queue Level for SGCP 1
level = CSL_TAC_SGCP_getCPMQWatermark(1);
...
</pre> 
</div>
</div>
<a class="anchor" id="gab3cfdb87746a3b237a96b04e97004093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_getCycleOverflowStatus </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___t_a_c___s_g_c_p__cycle_overflow_status.html">CSL_TAC_SGCP_cycleOverflowStatus</a> *&#160;</td>
          <td class="paramname"><em>cycleOverflowStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getCycleOverflowStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the task and page Ids that form the SRM ID that was last active.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId              Which SGCP to get status from.

cycleOverflowStatus Structure with cycle over flow parameters.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_SGCP_CYC_OVER_ITE_NB, SGCP_CFG_SGCP_CYC_OVER_CYC_OVER_FLG, SGCP_CFG_SGCP_CYC_OVER_PAGE_IDX, SGCP_CFG_SGCP_CYC_OVER_TASK_IDX</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_SGCP_cycleOverflowStatus  cycleOverflowStatus;

...
// Get the status for SGCP 0
CSL_TAC_SGCP_getCycleOverflowStatus(0, &amp;cycleOverflowStatus);
...

// Get the status for SGCP 1
CSL_TAC_SGCP_getCycleOverflowStatus(1, &amp;cycleOverflowStatus);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga4ec8e9758ce2aa3435603eb1f23046ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_TAC_SGCP_getFetchQLevel </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getFetchQLevel</b> </p>
<p><b>Description</b> <br />
 This function returns the Fetching Transaction Queue Current Level for a given SGCP ID.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP Fetching queue current level to read.
</pre><p><b> Return Value </b> <br />
 The current value of the level</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_FTQ_CURR_LVL_CURR_LVL</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  level;

// Get the Queue Level for SGCP 0
level = CSL_TAC_SGCP_getFetchQLevel(0);
...

// Get the Queue Level for SGCP 1
level = CSL_TAC_SGCP_getFetchQLevel(1);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga212816db3cae67da66ba6a2a74cbf6c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_TAC_SGCP_getFetchQWatermark </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getFetchQWatermark</b> </p>
<p><b>Description</b> <br />
 This function returns the Fetching Transaction Queue Water Mark for a given SGCP ID.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP Fetching queue water mark to read.
</pre><p><b> Return Value </b> <br />
 The highest level of the queue.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Reading of this register resets the value to the current level.</p>
<p><b>Reads</b> <br />
 SGCP_CFG_FTQ_WTMK_LVL_WATERMARK</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  level;

// Get the Queue Level for SGCP 0
level = CSL_TAC_SGCP_getFetchQWatermark(0);
...

// Get the Queue Level for SGCP 1
level = CSL_TAC_SGCP_getFetchQWatermark(1);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga54cfb8c5fce7908639ad80d71f1d7f17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_getFIFOOverflowStatus </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___t_a_c___s_g_c_p__fifo_overflow_status.html">CSL_TAC_SGCP_fifoOverflowStatus</a> *&#160;</td>
          <td class="paramname"><em>fifoOverflowStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getFIFOOverflowStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the task and page Ids that form the SRM ID. This is the active task that tried to write into a full FIFO.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId              Which SGCP to get status from.

fifoOverflowStatus  Structure with FIFO over flow parameters
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_SGCP_FIFO_OVER_ITE_NB, SGCP_CFG_SGCP_FIFO_OVER_FIFO_ID, SGCP_CFG_SGCP_FIFO_OVER_CYC_OVER_FLG, SGCP_CFG_SGCP_FIFO_OVER_PAGE_IDX, SGCP_CFG_SGCP_FIFO_OVER_TASK_IDX</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_SGCP_fifoOverflowStatus  fifoOverflowStatus;

...
// Get the status for SGCP 0
CSL_TAC_SGCP_getFIFOOverflowStatus(0, &amp;fifoOverflowStatus);
...

// Get the status for SGCP 1
CSL_TAC_SGCP_getFIFOOverflowStatus(1, &amp;fifoOverflowStatus);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga87347d9ab3a96d72b48e9bcc4d225efd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_getReadTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___t_a_c___s_g_c_p___timestamp__req.html">CSL_TAC_SGCP_Timestamp_req</a> *&#160;</td>
          <td class="paramname"><em>timestamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getReadTime</b> </p>
<p><b>Description</b> <br />
 This function reads the SGCP 0 read timestamp register.</p>
<p><b>Arguments</b> </p><pre class="fragment">timestamp       Structure with timestamp parameters.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_SGCP_RD_SYS_TIME_CHIP_NB, SGCP_CFG_SGCP_RD_SYS_TIME_SLOT_NB, SGCP_CFG_SGCP_RD_SYS_TIME_FRAME_NB</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_SGCP_Timestamp_req  timestamp;

...
CSL_TAC_SGCP_getReadTime(&amp;timestamp);
...
</pre> 
</div>
</div>
<a class="anchor" id="gae2ab901a9eccc36db8a971c1b95b2948"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 CSL_TAC_SGCP_getSequencerCycles </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getSequencerCycles</b> </p>
<p><b>Description</b> <br />
 This function returns the number of sequencer-used cycles in the previous iteration.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP to get status from.
</pre><p><b> Return Value </b> <br />
 The number of cycles consumed by the sequencer.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_SGCP_SEQ_CYC_SEQ_COUNT</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  seqCycles;

// Get the Sequencer used cycles for SGCP 0
seqCycles = CSL_TAC_SGCP_getSequencerCycles(0);

// Get the Sequencer used cycles for SGCP 1
seqCycles = CSL_TAC_SGCP_getSequencerCycles(1);
</pre> 
</div>
</div>
<a class="anchor" id="ga1195c504e11e111b033368eb35fb165f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_getSymbolBuffMissStatus </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___t_a_c___s_g_c_p__symbol_buff_miss_status.html">CSL_TAC_SGCP_symbolBuffMissStatus</a> *&#160;</td>
          <td class="paramname"><em>symBuffMissStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getSymbolBuffMissStatus</b> </p>
<p><b>Description</b> <br />
 This function returns the task and page Ids that form the SRM ID. This is the symbol input buffer location where the write miss error occured.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId              Which SGCP to get status from.

symBuffMissStatus   Structure with symbol buffer miss parameters
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_SGCP_IB_MISS_ITE_NB, SGCP_CFG_SGCP_IB_MISS_WR_MISS, SGCP_CFG_SGCP_IB_MISS_PAGE_IDX, SGCP_CFG_SGCP_IB_MISS_TASK_IDX</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_SGCP_symbolBuffMissStatus  symBuffMissStatus;

...
// Get the status for SGCP 0
CSL_TAC_SGCP_getSymbolBuffMissStatus(0, &amp;symBuffMissStatus);
...

// Get the status for SGCP 1
CSL_TAC_SGCP_getSymbolBuffMissStatus(1, &amp;symBuffMissStatus);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga1574d86bdf3594e4d604f93d671529ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_TAC_SGCP_getWarningQLevel </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getWarningQLevel</b> </p>
<p><b>Description</b> <br />
 This function returns the Warning Transaction Queue Current Level for a given SGCP ID.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP warning queue current level to read.
</pre><p><b> Return Value </b> <br />
 The current value of the level</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 SGCP_CFG_WTQ_CURR_LVL_CURR_LVL</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  level;

// Get the Queue Level for SGCP 0
level = CSL_TAC_SGCP_getWarningQLevel(0);
...

// Get the Queue Level for SGCP 1
level = CSL_TAC_SGCP_getWarningQLevel(1);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga0a085b56cf30ad62ed7beae33aec9b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 CSL_TAC_SGCP_getWarningQWatermark </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_getWarningQWatermark</b> </p>
<p><b>Description</b> <br />
 This function returns the Warning Transaction Queue Water Mark for a given SGCP ID.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP warning queue water mark to read.
</pre><p><b> Return Value </b> <br />
 The highest level of the queue.</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 Reading of this register resets the value to the current level.</p>
<p><b>Reads</b> <br />
 SGCP_CFG_WTQ_WTMK_LVL_WATERMARK</p>
<p><b>Example</b> </p><pre class="fragment">Uint16  level;

// Get the Queue Level for SGCP 0
level = CSL_TAC_SGCP_getWarningQWatermark(0);
...

// Get the Queue Level for SGCP 1
level = CSL_TAC_SGCP_getWarningQWatermark(1);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga194862ca41dcb563e9c40ca7a34d3da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_resetCPMQueue </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_resetCPMQueue</b> </p>
<p><b>Description</b> <br />
 This function resets the Code Power Measurement Queue of the corresponding SGCP by writing into the <em>TAC_SGCP_FIFO_RESET</em> register.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP's FIFO to reset.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 SGCP_CFG_SGCP_FIFO_RESET_CPM_RESET=1</p>
<p><b>Affects</b> <br />
 SGCP_CFG_CTQ_WTMK_LVL_WATERMARK=0, SGCP_CFG_CTQ_CURR_LVL_CURR_LVL=0, SGCP_CFG_SGCP_FIFO_RESET_CPM_RESET=0</p>
<p><b>Example</b> </p><pre class="fragment">...
// Reset the Queue for SGCP 0
CSL_TAC_SGCP_resetCPMQueue(0);
...

// Reset the Queue for SGCP 1
CSL_TAC_SGCP_resetCPMQueue(1);
...
</pre> 
</div>
</div>
<a class="anchor" id="ga8e5738c18b769dd8c7da92a1f1cfb38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_resetCycleOverflowStatus </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_resetCycleOverflowStatus</b> </p>
<p><b>Description</b> <br />
 This function resets the Cycle overflow error status.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId              Which SGCP's error status to reset.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 SGCP_CFG_SGCP_CYC_OVER_CYC_OVER_FLG=1</p>
<p><b>Affects</b> <br />
 SGCP_CFG_SGCP_CYC_OVER_CYC_OVER_FLG=0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_SGCP_cycleOverflowStatus  cycleOverflowStatus;

...
// Get the status for SGCP 0
CSL_TAC_SGCP_getCycleOverflowStatus(0, &amp;cycleOverflowStatus);

if (cycleOverflowStatus.overflowFlag)
{
    CSL_TAC_SGCP_resetFIFOOverflowStatus(0);
}

// Get the status for SGCP 1
CSL_TAC_SGCP_getCycleOverflowStatus(1, &amp;cycleOverflowStatus);

if (cycleOverflowStatus.overflowFlag)
{
    CSL_TAC_SGCP_resetFIFOOverflowStatus(1);
}
</pre> 
</div>
</div>
<a class="anchor" id="gaddb3033f7749aedb6339e7042881426f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_resetFetchQueue </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_resetFetchQueue</b> </p>
<p><b>Description</b> <br />
 This function resets the Fetch Queue of the corresponding SGCP by writing into the <em>TAC_SGCP_FIFO_RESET</em> register.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP's FIFO to reset.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 SGCP_CFG_SGCP_FIFO_RESET_FETCH_RESET=1</p>
<p><b>Affects</b> <br />
 SGCP_CFG_FTQ_WTMK_LVL_WATERMARK=0, SGCP_CFG_FTQ_CURR_LVL_CURR_LVL=0, SGCP_CFG_SGCP_FIFO_RESET_FETCH_RESET=0</p>
<p><b>Example</b> </p><pre class="fragment">...
// Reset the Queue for SGCP 0
CSL_TAC_SGCP_resetFetchQueue(0);
...

// Reset the Queue for SGCP 1
CSL_TAC_SGCP_resetFetchQueue(1);
...
</pre> 
</div>
</div>
<a class="anchor" id="gaf157670447228377573affc5ca943e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_resetFIFOOverflowStatus </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_resetFIFOOverflowStatus</b> </p>
<p><b>Description</b> <br />
 This function resets the FIFO overflow error status.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId              Which SGCP's error status to reset.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 SGCP_CFG_SGCP_FIFO_OVER_CYC_OVER_FLG=1</p>
<p><b>Affects</b> <br />
 SGCP_CFG_SGCP_FIFO_OVER_CYC_OVER_FLG=0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_SGCP_fifoOverflowStatus  fifoOverflowStatus;

...
// Get the status for SGCP 0
CSL_TAC_SGCP_getFIFOOverflowStatus(0, &amp;fifoOverflowStatus);

if (fifoOverflowStatus.overflowFlag)
{
    CSL_TAC_SGCP_resetFIFOOverflowStatus(0);
}

// Get the status for SGCP 1
CSL_TAC_SGCP_getFIFOOverflowStatus(1, &amp;fifoOverflowStatus);

if (fifoOverflowStatus.overflowFlag)
{
    CSL_TAC_SGCP_resetFIFOOverflowStatus(1);
}
</pre> 
</div>
</div>
<a class="anchor" id="ga88d14cc530ae9904f7b10bba671176ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_resetSymbolBuffMissStatus </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_resetSymbolBuffMissStatus</b> </p>
<p><b>Description</b> <br />
 This function resets the Symbol Buffer Miss error status.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId              Which SGCP's error status to reset.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 SGCP_CFG_SGCP_IB_MISS_WR_MISS=1</p>
<p><b>Affects</b> <br />
 SGCP_CFG_SGCP_IB_MISS_WR_MISS=0</p>
<p><b>Example</b> </p><pre class="fragment">CSL_TAC_SGCP_symbolBuffMissStatus  symBuffMissStatus;

...
// Get the status for SGCP 0
CSL_TAC_SGCP_getSymbolBuffMissStatus(0, &amp;symBuffMissStatus);

if (symBuffMissStatus.writeMissFlag)
{
    CSL_TAC_SGCP_resetSymbolBuffMissStatus(0);
}

// Get the status for SGCP 1
CSL_TAC_SGCP_getSymbolBuffMissStatus(1, &amp;symBuffMissStatus);

if (symBuffMissStatus.writeMissFlag)
{
    CSL_TAC_SGCP_resetSymbolBuffMissStatus(1);
}
</pre> 
</div>
</div>
<a class="anchor" id="gafba0dedddf4ffafba95428b7d9596a03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_TAC_SGCP_resetWarningQueue </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>sgcpId</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><br />
<b>CSL_TAC_SGCP_resetWarningQueue</b> </p>
<p><b>Description</b> <br />
 This function resets the Warning Queue of the corresponding SGCP by writing into the <em>TAC_SGCP_FIFO_RESET</em> register.</p>
<p><b>Arguments</b> </p><pre class="fragment">sgcpId          Which SGCP's FIFO to reset.
</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 SGCP_CFG_SGCP_FIFO_RESET_WARN_RESET=1</p>
<p><b>Affects</b> <br />
 SGCP_CFG_WTQ_WTMK_LVL_WATERMARK=0, SGCP_CFG_WTQ_CURR_LVL_CURR_LVL=0, SGCP_CFG_SGCP_FIFO_RESET_WARN_RESET=0</p>
<p><b>Example</b> </p><pre class="fragment">...
// Reset the Queue for SGCP 0
CSL_TAC_SGCP_resetWarningQueue(0);
...

// Reset the Queue for SGCP 1
CSL_TAC_SGCP_resetWarningQueue(1);
...
</pre> 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
