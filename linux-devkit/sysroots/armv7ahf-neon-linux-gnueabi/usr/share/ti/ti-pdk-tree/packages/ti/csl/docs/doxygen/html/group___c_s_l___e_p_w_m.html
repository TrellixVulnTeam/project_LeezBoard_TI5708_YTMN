<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>EPWM</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EPWM<div class="ingroups"><a class="el" href="group___c_s_l___i_p___m_o_d_u_l_e.html">IP</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_timebase_cfg.html">CSL_EpwmTimebaseCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the TimeBase sub-module configuration parameters.  <a href="struct_c_s_l___epwm_timebase_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_counter_cmp_cfg.html">CSL_EpwmCounterCmpCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Counter Comparator values.  <a href="struct_c_s_l___epwm_counter_cmp_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_aq_action_cfg.html">CSL_EpwmAqActionCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Action Qualifier actions to be taken on the PWM output at the specific events.  <a href="struct_c_s_l___epwm_aq_action_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_deadband_cfg.html">CSL_EpwmDeadbandCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the dead band generation sub-module configuration parameters.  <a href="struct_c_s_l___epwm_deadband_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_chopper_cfg.html">CSL_EpwmChopperCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the configuration parameters of Chopper sub-module.  <a href="struct_c_s_l___epwm_chopper_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_tripzone_cfg.html">CSL_EpwmTripzoneCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the trip-zone sub-module configuration parameters.  <a href="struct_c_s_l___epwm_tripzone_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_et_cfg.html">CSL_EpwmEtCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Event Trigger Sub-Module configuration parameters.  <a href="struct_c_s_l___epwm_et_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_s_l___epwm_high_resolution_cfg.html">CSL_EpwmHighResolutionCfg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the configuration parameters of high resolution pwm pulse generation sub module.  <a href="struct_c_s_l___epwm_high_resolution_cfg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gabbbbb6eda9084cd2713ae3a282f38170"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabbbbb6eda9084cd2713ae3a282f38170"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga4672abaa68fac187b71c0cb03c7280cb">CSL_EpwmOutputCh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabbbbb6eda9084cd2713ae3a282f38170">CSL_EpwmOutputCh_t</a></td></tr>
<tr class="memdesc:gabbbbb6eda9084cd2713ae3a282f38170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported EPWM outputs in a single epwm channel. <br /></td></tr>
<tr class="separator:gabbbbb6eda9084cd2713ae3a282f38170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49eb987b4b1bdfaf306d388088754f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad49eb987b4b1bdfaf306d388088754f5"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga36504709deb5986c35b50afa2cee8fe7">CSL_EpwmTbCounterDir</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad49eb987b4b1bdfaf306d388088754f5">CSL_EpwmTbCounterDir_t</a></td></tr>
<tr class="memdesc:gad49eb987b4b1bdfaf306d388088754f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Time base counter direction modes. <br /></td></tr>
<tr class="separator:gad49eb987b4b1bdfaf306d388088754f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f7a09a63c915d6a04097a58b4af1008"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga94bff6472785045fba9b46f3d3d60890">CSL_EpwmShadowRegCtrl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6f7a09a63c915d6a04097a58b4af1008">CSL_EpwmShadowRegCtrl_t</a></td></tr>
<tr class="memdesc:ga6f7a09a63c915d6a04097a58b4af1008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow register enable or disable control.  <a href="#ga6f7a09a63c915d6a04097a58b4af1008">More...</a><br /></td></tr>
<tr class="separator:ga6f7a09a63c915d6a04097a58b4af1008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7569a66aaa8b0d5ca68e009762c09abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7569a66aaa8b0d5ca68e009762c09abc"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga2a8df9e04db9dab6fced318b9a1b4781">CSL_EpwmTbCntDirAftSync</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7569a66aaa8b0d5ca68e009762c09abc">CSL_EpwmTbCntDirAftSync_t</a></td></tr>
<tr class="memdesc:ga7569a66aaa8b0d5ca68e009762c09abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter directions after sync event. <br /></td></tr>
<tr class="separator:ga7569a66aaa8b0d5ca68e009762c09abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf843e98441ebc2edf21ad5c354e2855d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf843e98441ebc2edf21ad5c354e2855d"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga81b34cdcaad3341541b27c1cd96013a1">CSL_EpwmTbSyncOutEvt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaf843e98441ebc2edf21ad5c354e2855d">CSL_EpwmTbSyncOutEvt_t</a></td></tr>
<tr class="memdesc:gaf843e98441ebc2edf21ad5c354e2855d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source of Synchronization output signal. <br /></td></tr>
<tr class="separator:gaf843e98441ebc2edf21ad5c354e2855d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6740927d05ff40e51dece1c1205a265"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6740927d05ff40e51dece1c1205a265"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga30fb54bc86a56cd9527228699876db33">CSL_EpwmTbSts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab6740927d05ff40e51dece1c1205a265">CSL_EpwmTbSts_t</a></td></tr>
<tr class="memdesc:gab6740927d05ff40e51dece1c1205a265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to get the different types of time base status. <br /></td></tr>
<tr class="separator:gab6740927d05ff40e51dece1c1205a265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc0d33deb92c765bb6eecaa4c6bfbd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadbc0d33deb92c765bb6eecaa4c6bfbd6"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga193ed300ab9563ce954e632f8812654d">CSL_EpwmTbEmuMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gadbc0d33deb92c765bb6eecaa4c6bfbd6">CSL_EpwmTbEmuMode_t</a></td></tr>
<tr class="memdesc:gadbc0d33deb92c765bb6eecaa4c6bfbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulation Mode. This selects the behaviour of the ePWM time-base counter during emulation events. <br /></td></tr>
<tr class="separator:gadbc0d33deb92c765bb6eecaa4c6bfbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4095133466d3bd0f770d832c0c671f5d"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaf1e0c12be0466807de968eacfa1d2305">CSL_EpwmCcCmp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga4095133466d3bd0f770d832c0c671f5d">CSL_EpwmCcCmp_t</a></td></tr>
<tr class="separator:ga4095133466d3bd0f770d832c0c671f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49bb59c3a7915b1715fd9bdf453072e"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gabafad0ffb4ff526bd6f728f8e3f4b943">CSL_EpwmCcCmpLoadMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa49bb59c3a7915b1715fd9bdf453072e">CSL_EpwmCcCmpLoadMode_t</a></td></tr>
<tr class="memdesc:gaa49bb59c3a7915b1715fd9bdf453072e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter-Comparator registers(A and B) load mode flags from shadow register.  <a href="#gaa49bb59c3a7915b1715fd9bdf453072e">More...</a><br /></td></tr>
<tr class="separator:gaa49bb59c3a7915b1715fd9bdf453072e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805c562b6cb0b8523e4e2c9eede3a1b4"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga1a63042470127ffb20ab8d501911118b">CSL_EpwmAqAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga805c562b6cb0b8523e4e2c9eede3a1b4">CSL_EpwmAqAction_t</a></td></tr>
<tr class="memdesc:ga805c562b6cb0b8523e4e2c9eede3a1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Actions that Action Qualifier can take on the Output when the supported counter compare event occurs.  <a href="#ga805c562b6cb0b8523e4e2c9eede3a1b4">More...</a><br /></td></tr>
<tr class="separator:ga805c562b6cb0b8523e4e2c9eede3a1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5436d5c1b122f8d49b6702f2d5e88cc"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga6e78c68e4d7bd43886e3f2e794677599">CSL_EpwmAqSwTrigOtAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae5436d5c1b122f8d49b6702f2d5e88cc">CSL_EpwmAqSwTrigOtAction_t</a></td></tr>
<tr class="memdesc:gae5436d5c1b122f8d49b6702f2d5e88cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions to be taken on the output, when Software triggered one time events will occur.  <a href="#gae5436d5c1b122f8d49b6702f2d5e88cc">More...</a><br /></td></tr>
<tr class="separator:gae5436d5c1b122f8d49b6702f2d5e88cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c16860974e7b6a52688da47566539c"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga99aefc353ef1392b47281d6096610fbe">CSL_EpwmAqSwTrigContAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga31c16860974e7b6a52688da47566539c">CSL_EpwmAqSwTrigContAction_t</a></td></tr>
<tr class="memdesc:ga31c16860974e7b6a52688da47566539c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Continuous software forced actions on output.  <a href="#ga31c16860974e7b6a52688da47566539c">More...</a><br /></td></tr>
<tr class="separator:ga31c16860974e7b6a52688da47566539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea8bd98b5b6ad3840721cfaf74664d8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4ea8bd98b5b6ad3840721cfaf74664d8"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaf31be2041e0e3d8ee980bc3286bd824d">CSL_EpwmAqCsfrcRegReload</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga4ea8bd98b5b6ad3840721cfaf74664d8">CSL_EpwmAqCsfrcRegReload_t</a></td></tr>
<tr class="memdesc:ga4ea8bd98b5b6ad3840721cfaf74664d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action Qualifier Software Force Active Register Reload From Shadow Options. <br /></td></tr>
<tr class="separator:ga4ea8bd98b5b6ad3840721cfaf74664d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa4041709ae41b0f342bd36d9d8131b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6fa4041709ae41b0f342bd36d9d8131b"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga7f9ad7e313e22da2793af8551a87ec20">CSL_EpwmDbInMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6fa4041709ae41b0f342bd36d9d8131b">CSL_EpwmDbInMode_t</a></td></tr>
<tr class="memdesc:ga6fa4041709ae41b0f342bd36d9d8131b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead Band Input Mode Control. This allows you to select the input source to the falling-edge and rising-edge delay. <br /></td></tr>
<tr class="separator:ga6fa4041709ae41b0f342bd36d9d8131b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4042d5f1fb6c6c66fea9616ab57d288a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4042d5f1fb6c6c66fea9616ab57d288a"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga93879a1613c7b2d77e60d33a941da960">CSL_EpwmDbPolSel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga4042d5f1fb6c6c66fea9616ab57d288a">CSL_EpwmDbPolSel_t</a></td></tr>
<tr class="memdesc:ga4042d5f1fb6c6c66fea9616ab57d288a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polarity Select Control. This allows you to selectively invert one of the delayed signals before it is sent out of the dead-band sub-module. <br /></td></tr>
<tr class="separator:ga4042d5f1fb6c6c66fea9616ab57d288a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf5a7823d8a59ea1fb034e91294946b8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabf5a7823d8a59ea1fb034e91294946b8"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga553301c918cd875b997bfc4a5b2a9e57">CSL_EpwmDbOutMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabf5a7823d8a59ea1fb034e91294946b8">CSL_EpwmDbOutMode_t</a></td></tr>
<tr class="memdesc:gabf5a7823d8a59ea1fb034e91294946b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead-band Output Mode Control. This allows you to selectively enable or bypass the dead-band generation for the falling-edge and rising-edge delay. <br /></td></tr>
<tr class="separator:gabf5a7823d8a59ea1fb034e91294946b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99e861c90553d41d0c3d22acf858dec6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga99e861c90553d41d0c3d22acf858dec6"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga8b68ac038fbf4e0d88bdddcbda0c9c42">CSL_EpwmChpDutyCycle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga99e861c90553d41d0c3d22acf858dec6">CSL_EpwmChpDutyCycle_t</a></td></tr>
<tr class="memdesc:ga99e861c90553d41d0c3d22acf858dec6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chopping Clock Duty Cycle values. <br /></td></tr>
<tr class="separator:ga99e861c90553d41d0c3d22acf858dec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e6f89c2988475b80d6710e999c82f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga24e6f89c2988475b80d6710e999c82f4"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaa268fe53917e58604cee84c2663590db">CSL_EpwmChpClkFreq</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga24e6f89c2988475b80d6710e999c82f4">CSL_EpwmChpClkFreq_t</a></td></tr>
<tr class="memdesc:ga24e6f89c2988475b80d6710e999c82f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chopping Clock Frequency values . <br /></td></tr>
<tr class="separator:ga24e6f89c2988475b80d6710e999c82f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9790d97419cbe79a4925df7a96f36d7b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9790d97419cbe79a4925df7a96f36d7b"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga98e2de17e835f8403866e61589f7d2c7">CSL_EpwmChpOshtWidth</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga9790d97419cbe79a4925df7a96f36d7b">CSL_EpwmChpOshtWidth_t</a></td></tr>
<tr class="memdesc:ga9790d97419cbe79a4925df7a96f36d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-Shot Pulse Width values. <br /></td></tr>
<tr class="separator:ga9790d97419cbe79a4925df7a96f36d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf2f55aca379fc7846538bed71ef049"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaa9c1aa65bb06a11eefbd84871d3deeb2">CSL_EpwmTzTripAction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6bf2f55aca379fc7846538bed71ef049">CSL_EpwmTzTripAction_t</a></td></tr>
<tr class="memdesc:ga6bf2f55aca379fc7846538bed71ef049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action to be taken on PWM output When a trip event occurs.  <a href="#ga6bf2f55aca379fc7846538bed71ef049">More...</a><br /></td></tr>
<tr class="separator:ga6bf2f55aca379fc7846538bed71ef049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb57b10cbea2b0be2acfe603b4c46648"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabb57b10cbea2b0be2acfe603b4c46648"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gacdb6aa144118af5cb8445a6c02078b77">CSL_EpwmTzEvent</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabb57b10cbea2b0be2acfe603b4c46648">CSL_EpwmTzEvent_t</a></td></tr>
<tr class="memdesc:gabb57b10cbea2b0be2acfe603b4c46648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of trip zone events. <br /></td></tr>
<tr class="separator:gabb57b10cbea2b0be2acfe603b4c46648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga677ca062d4c7ecb97857775e28f1a7e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga677ca062d4c7ecb97857775e28f1a7e0"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga3fb1ccf4c19a96a1dfe82d0d995bacde">CSL_EpwmTzStsFlg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga677ca062d4c7ecb97857775e28f1a7e0">CSL_EpwmTzStsFlg_t</a></td></tr>
<tr class="memdesc:ga677ca062d4c7ecb97857775e28f1a7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trip zone status flags. <br /></td></tr>
<tr class="separator:ga677ca062d4c7ecb97857775e28f1a7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542ee551a622c54100853d42223597b4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga542ee551a622c54100853d42223597b4"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga96b0cd3bf0e3d6ae93df93f8673645ed">CSL_EpwmEtIntrEvt</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga542ee551a622c54100853d42223597b4">CSL_EpwmEtIntrEvt_t</a></td></tr>
<tr class="memdesc:ga542ee551a622c54100853d42223597b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">ePWM Interrupt (EPWMx_INT) Selection Options. <br /></td></tr>
<tr class="separator:ga542ee551a622c54100853d42223597b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacecebb3e46dae00e204b6bdba8d7ebb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacecebb3e46dae00e204b6bdba8d7ebb2"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaed90cf6c53e6d1efe9a91614c4777c4f">CSL_EpwmEtIntrPeriod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacecebb3e46dae00e204b6bdba8d7ebb2">CSL_EpwmEtIntrPeriod_t</a></td></tr>
<tr class="memdesc:gacecebb3e46dae00e204b6bdba8d7ebb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">ePWM Interrupt (EPWMx_INT) Period Select. These values determine how many selected events need to occur before an interrupt is generated. <br /></td></tr>
<tr class="separator:gacecebb3e46dae00e204b6bdba8d7ebb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92f26c15c4ab3a8d58492b3a50831e54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga92f26c15c4ab3a8d58492b3a50831e54"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gacd86ffb64b20b88fe50010c6661dfb0f">CSL_EpwmHrDelayBusSel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga92f26c15c4ab3a8d58492b3a50831e54">CSL_EpwmHrDelayBusSelMode_t</a></td></tr>
<tr class="memdesc:ga92f26c15c4ab3a8d58492b3a50831e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay Bus Selection, that selects which bus is used to select the delay for the PWM pulse. <br /></td></tr>
<tr class="separator:ga92f26c15c4ab3a8d58492b3a50831e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac587cbead83f9079cbcf9f066e7e9a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaac587cbead83f9079cbcf9f066e7e9a8"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gae843cd74e089d1082a6b9a6cf99cc8cc">CSL_EpwmHrDelayEdgeCtrl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaac587cbead83f9079cbcf9f066e7e9a8">CSL_EpwmHrDelayEdgeCtrl_t</a></td></tr>
<tr class="memdesc:gaac587cbead83f9079cbcf9f066e7e9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay Mode Configuration, that selects which edge of the PWM pulse the delay is inserted. <br /></td></tr>
<tr class="separator:gaac587cbead83f9079cbcf9f066e7e9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593ac8153b1dd188574f3e6e00db96d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga593ac8153b1dd188574f3e6e00db96d0"></a>
typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gad67e0340fa97724992f320582e9d4ff9">CSL_EpwmHrRegActLoad</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga593ac8153b1dd188574f3e6e00db96d0">CSL_EpwmHrRegActLoad_t</a></td></tr>
<tr class="memdesc:ga593ac8153b1dd188574f3e6e00db96d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulse selection, that selects which pulse to use for timing events in the HRPWM module. <br /></td></tr>
<tr class="separator:ga593ac8153b1dd188574f3e6e00db96d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf4da9ae0133524b06dcbc6332a1efdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf4da9ae0133524b06dcbc6332a1efdf"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_timebase_cfg.html">CSL_EpwmTimebaseCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gadf4da9ae0133524b06dcbc6332a1efdf">CSL_EpwmTimebaseCfg_t</a></td></tr>
<tr class="memdesc:gadf4da9ae0133524b06dcbc6332a1efdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the TimeBase sub-module configuration parameters. <br /></td></tr>
<tr class="separator:gadf4da9ae0133524b06dcbc6332a1efdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949100d20e14bbdb72a0e905855385d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga949100d20e14bbdb72a0e905855385d1"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_counter_cmp_cfg.html">CSL_EpwmCounterCmpCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga949100d20e14bbdb72a0e905855385d1">CSL_EpwmCounterCmpCfg_t</a></td></tr>
<tr class="memdesc:ga949100d20e14bbdb72a0e905855385d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Counter Comparator values. <br /></td></tr>
<tr class="separator:ga949100d20e14bbdb72a0e905855385d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3bc020da4d3d9c9c13d5259e44e2ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaaa3bc020da4d3d9c9c13d5259e44e2ad"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_aq_action_cfg.html">CSL_EpwmAqActionCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaaa3bc020da4d3d9c9c13d5259e44e2ad">CSL_EpwmAqActionCfg_t</a></td></tr>
<tr class="memdesc:gaaa3bc020da4d3d9c9c13d5259e44e2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Action Qualifier actions to be taken on the PWM output at the specific events. <br /></td></tr>
<tr class="separator:gaaa3bc020da4d3d9c9c13d5259e44e2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4201245ce28a464ac9e1493d06f19f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad4201245ce28a464ac9e1493d06f19f9"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_deadband_cfg.html">CSL_EpwmDeadbandCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad4201245ce28a464ac9e1493d06f19f9">CSL_EpwmDeadbandCfg_t</a></td></tr>
<tr class="memdesc:gad4201245ce28a464ac9e1493d06f19f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the dead band generation sub-module configuration parameters. <br /></td></tr>
<tr class="separator:gad4201245ce28a464ac9e1493d06f19f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga494e3bbf20e23cebda4ffb422961c7ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga494e3bbf20e23cebda4ffb422961c7ba"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_chopper_cfg.html">CSL_EpwmChopperCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga494e3bbf20e23cebda4ffb422961c7ba">CSL_EpwmChopperCfg_t</a></td></tr>
<tr class="memdesc:ga494e3bbf20e23cebda4ffb422961c7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the configuration parameters of Chopper sub-module. <br /></td></tr>
<tr class="separator:ga494e3bbf20e23cebda4ffb422961c7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb7ffc02fe32205386e610e8997665e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeb7ffc02fe32205386e610e8997665e8"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_tripzone_cfg.html">CSL_EpwmTripzoneCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaeb7ffc02fe32205386e610e8997665e8">CSL_EpwmTripzoneCfg_t</a></td></tr>
<tr class="memdesc:gaeb7ffc02fe32205386e610e8997665e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the trip-zone sub-module configuration parameters. <br /></td></tr>
<tr class="separator:gaeb7ffc02fe32205386e610e8997665e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ef90980865a22194ee0995c165b834"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga89ef90980865a22194ee0995c165b834"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_et_cfg.html">CSL_EpwmEtCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga89ef90980865a22194ee0995c165b834">CSL_EpwmEtCfg_t</a></td></tr>
<tr class="memdesc:ga89ef90980865a22194ee0995c165b834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the Event Trigger Sub-Module configuration parameters. <br /></td></tr>
<tr class="separator:ga89ef90980865a22194ee0995c165b834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00bea47184b64be843a9a1f427b8579"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa00bea47184b64be843a9a1f427b8579"></a>
typedef struct <a class="el" href="struct_c_s_l___epwm_high_resolution_cfg.html">CSL_EpwmHighResolutionCfg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa00bea47184b64be843a9a1f427b8579">CSL_EpwmHighResolutionCfg_t</a></td></tr>
<tr class="memdesc:gaa00bea47184b64be843a9a1f427b8579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure holding the configuration parameters of high resolution pwm pulse generation sub module. <br /></td></tr>
<tr class="separator:gaa00bea47184b64be843a9a1f427b8579"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga4672abaa68fac187b71c0cb03c7280cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga4672abaa68fac187b71c0cb03c7280cb">CSL_EpwmOutputCh</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga4672abaa68fac187b71c0cb03c7280cbab7f6d360159df2f6eb2bd9840781007a">CSL_EPWM_OUTPUT_CH_MIN</a> = 0U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga4672abaa68fac187b71c0cb03c7280cba82733cc259cd89324d030efde59aa861">CSL_EPWM_OUTPUT_CH_A</a> = CSL_EPWM_OUTPUT_CH_MIN, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga4672abaa68fac187b71c0cb03c7280cba391c9df922265c118516435d51715405">CSL_EPWM_OUTPUT_CH_B</a> = 1U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga4672abaa68fac187b71c0cb03c7280cba6c17bd99f9a99035efc40f108b993de3">CSL_EPWM_OUTPUT_CH_MAX</a> = CSL_EPWM_OUTPUT_CH_B
 }</td></tr>
<tr class="memdesc:ga4672abaa68fac187b71c0cb03c7280cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of supported EPWM outputs in a single epwm channel.  <a href="group___c_s_l___e_p_w_m.html#ga4672abaa68fac187b71c0cb03c7280cb">More...</a><br /></td></tr>
<tr class="separator:ga4672abaa68fac187b71c0cb03c7280cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36504709deb5986c35b50afa2cee8fe7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga36504709deb5986c35b50afa2cee8fe7">CSL_EpwmTbCounterDir</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga36504709deb5986c35b50afa2cee8fe7a07dff478b3a4b55c95d57efd94bab4b7">CSL_EPWM_TB_COUNTER_DIR_UP</a> = PWMSS_EPWM_TBCTL_CTRMODE_UP_COUNT, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga36504709deb5986c35b50afa2cee8fe7ad11775a755ea7abb9c0dbf13a9ac736e">CSL_EPWM_TB_COUNTER_DIR_DOWN</a> = PWMSS_EPWM_TBCTL_CTRMODE_DOWN_COUNT, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga36504709deb5986c35b50afa2cee8fe7a52ec32244b91b906a1c8b3e9ec5d6fd6">CSL_EPWM_TB_COUNTER_DIR_UP_DOWN</a> = PWMSS_EPWM_TBCTL_CTRMODE_UP_DOWN_COUNT, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga36504709deb5986c35b50afa2cee8fe7aa58311ff6066c644f575f89fdf507187">CSL_EPWM_TB_COUNTER_DIR_STOP</a> = PWMSS_EPWM_TBCTL_CTRMODE_STOP_FREEZE
 }</td></tr>
<tr class="memdesc:ga36504709deb5986c35b50afa2cee8fe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Time base counter direction modes.  <a href="group___c_s_l___e_p_w_m.html#ga36504709deb5986c35b50afa2cee8fe7">More...</a><br /></td></tr>
<tr class="separator:ga36504709deb5986c35b50afa2cee8fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94bff6472785045fba9b46f3d3d60890"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga94bff6472785045fba9b46f3d3d60890">CSL_EpwmShadowRegCtrl</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga94bff6472785045fba9b46f3d3d60890a7a8dc0ecf53af94ee5d75c2c013a962e">CSL_EPWM_SHADOW_REG_CTRL_ENABLE</a> = PWMSS_EPWM_TBCTL_PRDLD_LOAD_FROM_SHADOW, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga94bff6472785045fba9b46f3d3d60890a49145a26a25c386dac6abaec9d557a7d">CSL_EPWM_SHADOW_REG_CTRL_DISABLE</a> = PWMSS_EPWM_TBCTL_PRDLD_LOAD_IMMEDIATELY
 }</td></tr>
<tr class="memdesc:ga94bff6472785045fba9b46f3d3d60890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shadow register enable or disable control.  <a href="group___c_s_l___e_p_w_m.html#ga94bff6472785045fba9b46f3d3d60890">More...</a><br /></td></tr>
<tr class="separator:ga94bff6472785045fba9b46f3d3d60890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a8df9e04db9dab6fced318b9a1b4781"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga2a8df9e04db9dab6fced318b9a1b4781">CSL_EpwmTbCntDirAftSync</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga2a8df9e04db9dab6fced318b9a1b4781aa9ab8e7c57da41a371b870769cccbd4b">CSL_EPWM_TB_CNT_DIR_AFT_SYNC_DOWN</a> = PWMSS_EPWM_TBCTL_PHSDIR_COUNT_DOWN, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga2a8df9e04db9dab6fced318b9a1b4781a74af69d36dd75c3a3a858fe5e90e9301">CSL_EPWM_TB_CNT_DIR_AFT_SYNC_UP</a> = PWMSS_EPWM_TBCTL_PHSDIR_COUNT_UP
 }</td></tr>
<tr class="memdesc:ga2a8df9e04db9dab6fced318b9a1b4781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter directions after sync event.  <a href="group___c_s_l___e_p_w_m.html#ga2a8df9e04db9dab6fced318b9a1b4781">More...</a><br /></td></tr>
<tr class="separator:ga2a8df9e04db9dab6fced318b9a1b4781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b34cdcaad3341541b27c1cd96013a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga81b34cdcaad3341541b27c1cd96013a1">CSL_EpwmTbSyncOutEvt</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga81b34cdcaad3341541b27c1cd96013a1ad588d42ae5b01176c3ce9b6fe238fdef">CSL_EPWM_TB_SYNC_OUT_EVT_SYNCIN</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga81b34cdcaad3341541b27c1cd96013a1a63b4c4d19c895497403c3100cc14697d">CSL_EPWM_TB_SYNC_OUT_EVT_CNT_EQ_ZERO</a> = PWMSS_EPWM_TBCTL_SYNCOSEL_CTR_0, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga81b34cdcaad3341541b27c1cd96013a1a16f93abf61d1e57163f982aed79fbb5b">CSL_EPWM_TB_SYNC_OUT_EVT_CNT_EQ_CMP_B</a> = PWMSS_EPWM_TBCTL_SYNCOSEL_CTR_CPMB, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga81b34cdcaad3341541b27c1cd96013a1a40caee29ba9c279a3ff651d512d44e33">CSL_EPWM_TB_SYNC_OUT_EVT_DISABLE</a>
 }</td></tr>
<tr class="memdesc:ga81b34cdcaad3341541b27c1cd96013a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source of Synchronization output signal.  <a href="group___c_s_l___e_p_w_m.html#ga81b34cdcaad3341541b27c1cd96013a1">More...</a><br /></td></tr>
<tr class="separator:ga81b34cdcaad3341541b27c1cd96013a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fb54bc86a56cd9527228699876db33"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga30fb54bc86a56cd9527228699876db33">CSL_EpwmTbSts</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga30fb54bc86a56cd9527228699876db33a3295177e33da23c490ce72fc5a9d0e26">EPWM_TB_STS_CTR_MAX</a> = PWMSS_EPWM_TBSTS_CTRMAX_MASK, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga30fb54bc86a56cd9527228699876db33ae1b54ab00327a469d6126f25f088cff7">EPWM_TB_STS_SYNCI</a> = PWMSS_EPWM_TBSTS_SYNCI_MASK, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga30fb54bc86a56cd9527228699876db33a218eed14c2dc83e2a9948ee77e8db06d">EPWM_TB_STS_CTR_DIR</a> = PWMSS_EPWM_TBSTS_CTRDIR_MASK
 }</td></tr>
<tr class="memdesc:ga30fb54bc86a56cd9527228699876db33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags to get the different types of time base status.  <a href="group___c_s_l___e_p_w_m.html#ga30fb54bc86a56cd9527228699876db33">More...</a><br /></td></tr>
<tr class="separator:ga30fb54bc86a56cd9527228699876db33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga193ed300ab9563ce954e632f8812654d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga193ed300ab9563ce954e632f8812654d">CSL_EpwmTbEmuMode</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga193ed300ab9563ce954e632f8812654dac3d8584ee88c1872013fda8767df279c">CSL_EPWM_TB_EMU_MODE_STP_AFT_NEXT_CYCLE</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga193ed300ab9563ce954e632f8812654da22e9885e361424dd0fc5e40b9b938d18">CSL_EPWM_TB_EMU_MODE_STP_AFT_COMPLETE_CYCLE</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga193ed300ab9563ce954e632f8812654dae9e91cb0ce2c3fd8206861d5455dac1d">EPWM_TB_EMU_MODE_FREE_RUN</a> = PWMSS_EPWM_TBCTL_FREE_SOFT_RUN2
 }</td></tr>
<tr class="memdesc:ga193ed300ab9563ce954e632f8812654d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulation Mode. This selects the behaviour of the ePWM time-base counter during emulation events.  <a href="group___c_s_l___e_p_w_m.html#ga193ed300ab9563ce954e632f8812654d">More...</a><br /></td></tr>
<tr class="separator:ga193ed300ab9563ce954e632f8812654d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1e0c12be0466807de968eacfa1d2305"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaf1e0c12be0466807de968eacfa1d2305">CSL_EpwmCcCmp</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggaf1e0c12be0466807de968eacfa1d2305a9bc936b046013a9f6e5befdc7666abb2">CSL_EPWM_CC_CMP_MIN</a> = 0U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaf1e0c12be0466807de968eacfa1d2305a5c3591e5e90b8e2c807f1624b4808a15">CSL_EPWM_CC_CMP_A</a> = CSL_EPWM_CC_CMP_MIN, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaf1e0c12be0466807de968eacfa1d2305ad98c40de48f776c939a7bd83a01eab08">CSL_EPWM_CC_CMP_B</a> = 1U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaf1e0c12be0466807de968eacfa1d2305a5021ed73047ae4c447de600342ad24c6">CSL_EPWM_CC_CMP_MAX</a> = CSL_EPWM_CC_CMP_B
 }</td></tr>
<tr class="separator:gaf1e0c12be0466807de968eacfa1d2305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabafad0ffb4ff526bd6f728f8e3f4b943"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabafad0ffb4ff526bd6f728f8e3f4b943">CSL_EpwmCcCmpLoadMode</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggabafad0ffb4ff526bd6f728f8e3f4b943a778b20673a79f03f39472fe1348b40fc">CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_ZERO</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggabafad0ffb4ff526bd6f728f8e3f4b943a4bc853357e2880d26981da7c48fbad3a">CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_PRD</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggabafad0ffb4ff526bd6f728f8e3f4b943a1e2eb6054a67cba5e9c47d29591a79d5">CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_ZERO_OR_PRD</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggabafad0ffb4ff526bd6f728f8e3f4b943a99d5bf6e08505f041e676c826c4aee1b">CSL_EPWM_CC_CMP_LOAD_MODE_NO_LOAD</a>
 }</td></tr>
<tr class="memdesc:gabafad0ffb4ff526bd6f728f8e3f4b943"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter-Comparator registers(A and B) load mode flags from shadow register.  <a href="group___c_s_l___e_p_w_m.html#gabafad0ffb4ff526bd6f728f8e3f4b943">More...</a><br /></td></tr>
<tr class="separator:gabafad0ffb4ff526bd6f728f8e3f4b943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a63042470127ffb20ab8d501911118b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1a63042470127ffb20ab8d501911118b">CSL_EpwmAqAction</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga1a63042470127ffb20ab8d501911118ba34260a2cfbf91b3c24465eadbb9cb0eb">CSL_EPWM_AQ_ACTION_DONOTHING</a> = PWMSS_EPWM_AQCTLA_ZRO_DISABLED, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga1a63042470127ffb20ab8d501911118bad7641d7629a601262885f6f2068c78e9">CSL_EPWM_AQ_ACTION_LOW</a> = PWMSS_EPWM_AQCTLA_ZRO_CLEAR, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga1a63042470127ffb20ab8d501911118bac79689946ad100f315daa07aa15f12fa">CSL_EPWM_AQ_ACTION_HIGH</a> = PWMSS_EPWM_AQCTLA_ZRO_SET, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga1a63042470127ffb20ab8d501911118ba378ee34781b778fe278056770e7fb455">CSL_EPQM_AQ_ACTION_TOLLGE</a> = PWMSS_EPWM_AQCTLA_ZRO_TOGGLE
 }</td></tr>
<tr class="memdesc:ga1a63042470127ffb20ab8d501911118b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Actions that Action Qualifier can take on the Output when the supported counter compare event occurs.  <a href="group___c_s_l___e_p_w_m.html#ga1a63042470127ffb20ab8d501911118b">More...</a><br /></td></tr>
<tr class="separator:ga1a63042470127ffb20ab8d501911118b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e78c68e4d7bd43886e3f2e794677599"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga6e78c68e4d7bd43886e3f2e794677599">CSL_EpwmAqSwTrigOtAction</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga6e78c68e4d7bd43886e3f2e794677599af97f3f900f40e1122c76e8e181753de2">CSL_EPWM_AQ_SW_TRIG_OT_ACTION_DONOTHING</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga6e78c68e4d7bd43886e3f2e794677599a50f22b5604eb04263f0c11b63021a806">CSL_EPWM_AQ_SW_TRIG_OT_ACTION_LOW</a> = PWMSS_EPWM_AQSFRC_ACTSFA_CLEAR, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga6e78c68e4d7bd43886e3f2e794677599aa6779a86f4d9aa98e5fbc4ffcea60670">CSL_EPWM_AQ_SW_TRIG_OT_ACTION_HIGH</a> = PWMSS_EPWM_AQSFRC_ACTSFA_SET, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga6e78c68e4d7bd43886e3f2e794677599a523897698aecdcf44cc5c1a2949004f3">CSL_EPWM_AQ_SW_TRIG_OT_ACTION_TOGGLE</a> = PWMSS_EPWM_AQSFRC_ACTSFA_TOGGLE
 }</td></tr>
<tr class="memdesc:ga6e78c68e4d7bd43886e3f2e794677599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions to be taken on the output, when Software triggered one time events will occur.  <a href="group___c_s_l___e_p_w_m.html#ga6e78c68e4d7bd43886e3f2e794677599">More...</a><br /></td></tr>
<tr class="separator:ga6e78c68e4d7bd43886e3f2e794677599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99aefc353ef1392b47281d6096610fbe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga99aefc353ef1392b47281d6096610fbe">CSL_EpwmAqSwTrigContAction</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga99aefc353ef1392b47281d6096610fbeaef9276b60b40a89d347e74aedf340379">CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_NOEFFECT</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga99aefc353ef1392b47281d6096610fbeaeb1d0e94acbf6df5c4840cc95298bc25">CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_LOW</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga99aefc353ef1392b47281d6096610fbea5784c1a23c4f6638e5dc9048f2e182a1">CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_HIGH</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga99aefc353ef1392b47281d6096610fbea042c0fd5155466407b1adbbe25d174d6">CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_SW_DISBALED</a>
 }</td></tr>
<tr class="memdesc:ga99aefc353ef1392b47281d6096610fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of Continuous software forced actions on output.  <a href="group___c_s_l___e_p_w_m.html#ga99aefc353ef1392b47281d6096610fbe">More...</a><br /></td></tr>
<tr class="separator:ga99aefc353ef1392b47281d6096610fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf31be2041e0e3d8ee980bc3286bd824d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaf31be2041e0e3d8ee980bc3286bd824d">CSL_EpwmAqCsfrcRegReload</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggaf31be2041e0e3d8ee980bc3286bd824da9115a85d3dd16e591982a03af69d0792">CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_ZRO</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaf31be2041e0e3d8ee980bc3286bd824daac7d5425ffe30e01c40fabf774eb2764">CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_PRD</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaf31be2041e0e3d8ee980bc3286bd824daa5e7b5cef264bb6f523775b2a256b9c0">CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_ZRO_OR_PRD</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaf31be2041e0e3d8ee980bc3286bd824dac6e7af8180445da77d1e58da52799c73">CSL_EPWM_AQ_CSFRC_REG_RELOAD_IMMEDIATE</a>
 }</td></tr>
<tr class="memdesc:gaf31be2041e0e3d8ee980bc3286bd824d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action Qualifier Software Force Active Register Reload From Shadow Options.  <a href="group___c_s_l___e_p_w_m.html#gaf31be2041e0e3d8ee980bc3286bd824d">More...</a><br /></td></tr>
<tr class="separator:gaf31be2041e0e3d8ee980bc3286bd824d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f9ad7e313e22da2793af8551a87ec20"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7f9ad7e313e22da2793af8551a87ec20">CSL_EpwmDbInMode</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga7f9ad7e313e22da2793af8551a87ec20aa0737d25f6afcd3f969643b89b49ffc4">CSL_EPWM_DB_IN_MODE_A_RED_A_FED</a> = PWMSS_EPWM_DBCTL_IN_MODE_SRC_ARED_AFED, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga7f9ad7e313e22da2793af8551a87ec20ad5ce6b8b7f761059c4098db9acb948eb">CSL_EPWM_DB_IN_MODE_B_RED_A_FED</a> = PWMSS_EPWM_DBCTL_IN_MODE_SRC_BRED_AFED, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga7f9ad7e313e22da2793af8551a87ec20a3262770536d01acf3292de98a47f9b57">CSL_EPWM_DB_IN_MODE_A_RED_B_FED</a> = PWMSS_EPWM_DBCTL_IN_MODE_SRC_ARED_BFED, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga7f9ad7e313e22da2793af8551a87ec20a62184f1a9064a37e6793e97654ec6571">CSL_EPWM_DB_IN_MODE_B_RED_B_FED</a> = PWMSS_EPWM_DBCTL_IN_MODE_SRC_BRED_BFED
 }</td></tr>
<tr class="memdesc:ga7f9ad7e313e22da2793af8551a87ec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead Band Input Mode Control. This allows you to select the input source to the falling-edge and rising-edge delay.  <a href="group___c_s_l___e_p_w_m.html#ga7f9ad7e313e22da2793af8551a87ec20">More...</a><br /></td></tr>
<tr class="separator:ga7f9ad7e313e22da2793af8551a87ec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93879a1613c7b2d77e60d33a941da960"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga93879a1613c7b2d77e60d33a941da960">CSL_EpwmDbPolSel</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga93879a1613c7b2d77e60d33a941da960ab8e242fdbe66d81738dd0ff66bb3da50">CSL_EPWM_DB_POL_SEL_ACTV_HIGH</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga93879a1613c7b2d77e60d33a941da960ac35aabfd4fbb370b8a6d194c460fab48">CSL_EPWM_DB_POL_SEL_ACTV_LOW_COMPLEMENTARY</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga93879a1613c7b2d77e60d33a941da960a46dac6d1f7e4b1b719d059cf7c9f2bca">CSL_EPWM_DB_POL_SEL_ACTV_HIGH_COMPLEMENTARY</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga93879a1613c7b2d77e60d33a941da960ad2ce86787b92d2281646baa67f83282f">CSL_EPWM_DB_POL_SEL_ACTV_LOW</a>
 }</td></tr>
<tr class="memdesc:ga93879a1613c7b2d77e60d33a941da960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polarity Select Control. This allows you to selectively invert one of the delayed signals before it is sent out of the dead-band sub-module.  <a href="group___c_s_l___e_p_w_m.html#ga93879a1613c7b2d77e60d33a941da960">More...</a><br /></td></tr>
<tr class="separator:ga93879a1613c7b2d77e60d33a941da960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga553301c918cd875b997bfc4a5b2a9e57"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga553301c918cd875b997bfc4a5b2a9e57">CSL_EpwmDbOutMode</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga553301c918cd875b997bfc4a5b2a9e57a26f296641314d0d48cb9b7ce734845f7">CSL_EPWM_DB_OUT_MODE_BYPASS</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga553301c918cd875b997bfc4a5b2a9e57a07a297e8f8278713f4cd0db31a3fedd7">CSL_EPWM_DB_OUT_MODE_NO_RED_B_FED</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga553301c918cd875b997bfc4a5b2a9e57ac1e7e3af71947e310a5ae3c73928548e">CSL_EPWM_DB_OUT_MODE_A_RED_NO_FED</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga553301c918cd875b997bfc4a5b2a9e57ace913a9270f8deeb0a6a364371bfbcdb">CSL_EPWM_DB_OUT_MODE_A_RED_B_FED</a> = PWMSS_EPWM_DBCTL_OUT_MODE_ENABLED
 }</td></tr>
<tr class="memdesc:ga553301c918cd875b997bfc4a5b2a9e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dead-band Output Mode Control. This allows you to selectively enable or bypass the dead-band generation for the falling-edge and rising-edge delay.  <a href="group___c_s_l___e_p_w_m.html#ga553301c918cd875b997bfc4a5b2a9e57">More...</a><br /></td></tr>
<tr class="separator:ga553301c918cd875b997bfc4a5b2a9e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b68ac038fbf4e0d88bdddcbda0c9c42"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga8b68ac038fbf4e0d88bdddcbda0c9c42">CSL_EpwmChpDutyCycle</a> { <br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga8b68ac038fbf4e0d88bdddcbda0c9c42a4a11e33a3834d5aebef0823bd9499e4c">CSL_EPWM_CHP_DUTY_CYCLE_PERC_12PNT5</a> = PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_12_5, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga8b68ac038fbf4e0d88bdddcbda0c9c42aaa4efb096bb1e373891a80b7765e2150">CSL_EPWM_CHP_DUTY_CYCLE_PERC_25</a> = PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_25, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga8b68ac038fbf4e0d88bdddcbda0c9c42acf6479d385cf06fc8f7de07572b999c2">CSL_EPWM_CHP_DUTY_CYCLE_PERC_37PNT5</a> = PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_37_5, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga8b68ac038fbf4e0d88bdddcbda0c9c42a42f89670a50959f797e61b82c84563c1">CSL_EPWM_CHP_DUTY_CYCLE_PERC_50_PER</a> = PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_50, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga8b68ac038fbf4e0d88bdddcbda0c9c42aaa2bbeb82b0dad07ebeb567902566167">CSL_EPWM_CHP_DUTY_CYCLE_PERC_62PNT5</a> = PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_62_5, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga8b68ac038fbf4e0d88bdddcbda0c9c42ac6e4208f671cbee2a7fa5eaabdf60407">CSL_EPWM_CHP_DUTY_CYCLE_PERC_75</a> = PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_75, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga8b68ac038fbf4e0d88bdddcbda0c9c42a43b5ea3980d8a2b4ae4caf4f5ddfbdb2">CSL_EPWM_CHP_DUTY_CYCLE_PERC_87PNT5</a> = PWMSS_EPWM_PCCTL_CHPDUTY_DUTY_87_5
<br />
 }</td></tr>
<tr class="memdesc:ga8b68ac038fbf4e0d88bdddcbda0c9c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chopping Clock Duty Cycle values.  <a href="group___c_s_l___e_p_w_m.html#ga8b68ac038fbf4e0d88bdddcbda0c9c42">More...</a><br /></td></tr>
<tr class="separator:ga8b68ac038fbf4e0d88bdddcbda0c9c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa268fe53917e58604cee84c2663590db"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa268fe53917e58604cee84c2663590db">CSL_EpwmChpClkFreq</a> { <br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa268fe53917e58604cee84c2663590dba3d1bcfe2784e18c90d247056607c37e3">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_1</a> = PWMSS_EPWM_PCCTL_CHPFREQ_DIV_1, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa268fe53917e58604cee84c2663590dba40d7772b99f8a1525fdbc185f5af064b">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_2</a> = PWMSS_EPWM_PCCTL_CHPFREQ_DIV_2, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa268fe53917e58604cee84c2663590dbaf595125ab4cbdc508b1e393acb0cc301">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_3</a> = PWMSS_EPWM_PCCTL_CHPFREQ_DIV_3, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa268fe53917e58604cee84c2663590dbaf5d1bc9838aa12ec5a8f52e521046e7f">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_4</a> = PWMSS_EPWM_PCCTL_CHPFREQ_DIV_4, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa268fe53917e58604cee84c2663590dbac45b7640f61a4c56e84727dd518b6da8">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_5</a> = PWMSS_EPWM_PCCTL_CHPFREQ_DIV_5, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa268fe53917e58604cee84c2663590dbaa18d441e3117466def8df4c64ea27acc">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_6</a> = PWMSS_EPWM_PCCTL_CHPFREQ_DIV_6, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa268fe53917e58604cee84c2663590dba8bc1f2a61cd6abd2ca9dea5c04e803e4">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_7</a> = PWMSS_EPWM_PCCTL_CHPFREQ_DIV_7, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa268fe53917e58604cee84c2663590dbabe5f8eb1be0a122bcc589bf462863aeb">CSL_EPWM_CHP_CLK_FREQ_DIV_BY_8</a> = PWMSS_EPWM_PCCTL_CHPFREQ_DIV_8
<br />
 }</td></tr>
<tr class="memdesc:gaa268fe53917e58604cee84c2663590db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chopping Clock Frequency values .  <a href="group___c_s_l___e_p_w_m.html#gaa268fe53917e58604cee84c2663590db">More...</a><br /></td></tr>
<tr class="separator:gaa268fe53917e58604cee84c2663590db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e2de17e835f8403866e61589f7d2c7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga98e2de17e835f8403866e61589f7d2c7">CSL_EpwmChpOshtWidth</a> { <br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a8f79b82b61abfcd263229112a8c0f912">CSL_EPWM_CHP_OSHT_WIDTH_MIN</a> = 0U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7aacf86b6b93d920972afcb9f963021fb0">CSL_EPWM_CHP_OSHT_WIDTH_1XSYSOUT_BY_8</a> = CSL_EPWM_CHP_OSHT_WIDTH_MIN, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7adacb1080ee930ae88c9018f72fca1ef5">CSL_EPWM_CHP_OSHT_WIDTH_2XSYSOUT_BY_8</a> = 1U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a46a78b2924c20588287f0518489131e4">CSL_EPWM_CHP_OSHT_WIDTH_3XSYSOUT_BY_8</a> = 2U, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a1990f4acf25fef5def94ab6210ec08d4">CSL_EPWM_CHP_OSHT_WIDTH_4XSYSOUT_BY_8</a> = 3U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a8672538806780d66de4920f8c9866469">CSL_EPWM_CHP_OSHT_WIDTH_5XSYSOUT_BY_8</a> = 4U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a0bcaf19b06db46e383ba85c293d9e147">CSL_EPWM_CHP_OSHT_WIDTH_6XSYSOUT_BY_8</a> = 5U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7afac68f2e7edf22178e53f44f4675aeea">CSL_EPWM_CHP_OSHT_WIDTH_7XSYSOUT_BY_8</a> = 6U, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7acb8f974960a6a5723d2ca962aceeb5d1">CSL_EPWM_CHP_OSHT_WIDTH_8XSYSOUT_BY_8</a> = 7U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7aff559144eeba54c3efa63e939c516119">CSL_EPWM_CHP_OSHT_WIDTH_9XSYSOUT_BY_8</a> = 8U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7aff527deb6b19b14a981d761f6f5ad2c0">CSL_EPWM_CHP_OSHT_WIDTH_10XSYSOUT_BY_8</a> = 9U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a35eace1a36a3894e60678c18c85840d9">CSL_EPWM_CHP_OSHT_WIDTH_11XSYSOUT_BY_8</a> = 10U, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7acfb588cec1406cfec2216503644facec">CSL_EPWM_CHP_OSHT_WIDTH_12XSYSOUT_BY_8</a> = 11U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a0b28f709de771fbdd01721451e3181aa">CSL_EPWM_CHP_OSHT_WIDTH_13XSYSOUT_BY_8</a> = 12U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a56a9118a2f1ebc1055654fc2d74d8e83">CSL_EPWM_CHP_OSHT_WIDTH_14XSYSOUT_BY_8</a> = 13U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a78a0497f468046213591c85d48ed1113">CSL_EPWM_CHP_OSHT_WIDTH_15XSYSOUT_BY_8</a> = 14U, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7a21d257443f329c08d435b00eaab2e6ed">CSL_EPWM_CHP_OSHT_WIDTH_16XSYSOUT_BY_8</a> = 15U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga98e2de17e835f8403866e61589f7d2c7aa9c2274dca6869141e006ec1b56fe4b1">CSL_EPWM_CHP_OSHT_WIDTH_MAX</a>
<br />
 }</td></tr>
<tr class="memdesc:ga98e2de17e835f8403866e61589f7d2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">One-Shot Pulse Width values.  <a href="group___c_s_l___e_p_w_m.html#ga98e2de17e835f8403866e61589f7d2c7">More...</a><br /></td></tr>
<tr class="separator:ga98e2de17e835f8403866e61589f7d2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c1aa65bb06a11eefbd84871d3deeb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaa9c1aa65bb06a11eefbd84871d3deeb2">CSL_EpwmTzTripAction</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggaa9c1aa65bb06a11eefbd84871d3deeb2a8787e7040baa5408bff07be9d6dc8710">CSL_EPWM_TZ_TRIP_ACTION_TRI_STATE</a> = PWMSS_EPWM_TZCTL_TZA_HIGH_IMPEDANCE, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa9c1aa65bb06a11eefbd84871d3deeb2a059886e19557d89f0d895ca495d7baf9">CSL_EPWM_TZ_TRIP_ACTION_HIGH</a> = PWMSS_EPWM_TZCTL_TZA_HIGH_STATE, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa9c1aa65bb06a11eefbd84871d3deeb2a630b4738913d8cc34b3f2451cf47602a">CSL_EPWM_TZ_TRIP_ACTION_LOW</a> = PWMSS_EPWM_TZCTL_TZA_LOW_STATE, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaa9c1aa65bb06a11eefbd84871d3deeb2a6b1e7a2bf2b0e8f60a0eca9e0f154dcc">CSL_EPWM_TZ_TRIP_ACTION_DO_NOTHING</a> = PWMSS_EPWM_TZCTL_TZA_DO_NOTHING
 }</td></tr>
<tr class="memdesc:gaa9c1aa65bb06a11eefbd84871d3deeb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action to be taken on PWM output When a trip event occurs.  <a href="group___c_s_l___e_p_w_m.html#gaa9c1aa65bb06a11eefbd84871d3deeb2">More...</a><br /></td></tr>
<tr class="separator:gaa9c1aa65bb06a11eefbd84871d3deeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdb6aa144118af5cb8445a6c02078b77"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacdb6aa144118af5cb8445a6c02078b77">CSL_EpwmTzEvent</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggacdb6aa144118af5cb8445a6c02078b77a82262fc1074652c483208f21a151e6ef">CSL_EPWM_TZ_EVENT_MIN</a> = 0x0U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggacdb6aa144118af5cb8445a6c02078b77a94bafd9cefecc18f8d2b6a8975c7f0cf">CSL_EPWM_TZ_EVENT_ONE_SHOT</a> = CSL_EPWM_TZ_EVENT_MIN, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggacdb6aa144118af5cb8445a6c02078b77aa7946206fffe1986becddf7936fc3311">CSL_EPWM_TZ_EVENT_CYCLE_BY_CYCLE</a> = 0x1U, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggacdb6aa144118af5cb8445a6c02078b77a18ae11ed17b7e053ddda6a80f6c1cb70">CSL_EPWM_TZ_EVENT_MAX</a> = CSL_EPWM_TZ_EVENT_CYCLE_BY_CYCLE
 }</td></tr>
<tr class="memdesc:gacdb6aa144118af5cb8445a6c02078b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of trip zone events.  <a href="group___c_s_l___e_p_w_m.html#gacdb6aa144118af5cb8445a6c02078b77">More...</a><br /></td></tr>
<tr class="separator:gacdb6aa144118af5cb8445a6c02078b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fb1ccf4c19a96a1dfe82d0d995bacde"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga3fb1ccf4c19a96a1dfe82d0d995bacde">CSL_EpwmTzStsFlg</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#gga3fb1ccf4c19a96a1dfe82d0d995bacdea7504368543f2fbe76f8193b42cbe8c00">CSL_EPWM_TZ_STS_FLG_OST</a> = PWMSS_EPWM_TZFLG_OST_MASK, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga3fb1ccf4c19a96a1dfe82d0d995bacdea136349ed0c89a6b359506cd8c0c0f9d9">CSL_EPWM_TZ_STS_FLG_CBC</a> = PWMSS_EPWM_TZFLG_CBC_MASK, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga3fb1ccf4c19a96a1dfe82d0d995bacdea0ec542d1c722b605042c4879323f08a7">CSL_EPWM_TZ_STS_FLG_INT</a> = PWMSS_EPWM_TZFLG_INT_MASK
 }</td></tr>
<tr class="memdesc:ga3fb1ccf4c19a96a1dfe82d0d995bacde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trip zone status flags.  <a href="group___c_s_l___e_p_w_m.html#ga3fb1ccf4c19a96a1dfe82d0d995bacde">More...</a><br /></td></tr>
<tr class="separator:ga3fb1ccf4c19a96a1dfe82d0d995bacde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96b0cd3bf0e3d6ae93df93f8673645ed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga96b0cd3bf0e3d6ae93df93f8673645ed">CSL_EpwmEtIntrEvt</a> { <br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga96b0cd3bf0e3d6ae93df93f8673645eda43a5fc4a823dc35ffc64a0c7300dc269">CSL_EPWM_ET_INTR_EVT_CNT_EQ_ZRO</a> = PWMSS_EPWM_ETSEL_INTSEL_CTR_0, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga96b0cd3bf0e3d6ae93df93f8673645eda8dc350ef255c9b9e5cbece099fe90968">CSL_EPWM_ET_INTR_EVT_CNT_EQ_PRD</a> = PWMSS_EPWM_ETSEL_INTSEL_CTR_PERIOD, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga96b0cd3bf0e3d6ae93df93f8673645edadc4a44d9c1ad821001e40d22ea15360c">CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPA_INC</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga96b0cd3bf0e3d6ae93df93f8673645edae5ea9b64b51cf79646b684033251714a">CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPA_DEC</a>, 
<br />
&#160;&#160;<a class="el" href="group___c_s_l___e_p_w_m.html#gga96b0cd3bf0e3d6ae93df93f8673645eda6d1682dfc79fed7b493906e15ffe991b">CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPB_INC</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#gga96b0cd3bf0e3d6ae93df93f8673645eda1edbdd609cb98e6370576a266b967838">CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPB_DEC</a>
<br />
 }</td></tr>
<tr class="memdesc:ga96b0cd3bf0e3d6ae93df93f8673645ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">ePWM Interrupt (EPWMx_INT) Selection Options.  <a href="group___c_s_l___e_p_w_m.html#ga96b0cd3bf0e3d6ae93df93f8673645ed">More...</a><br /></td></tr>
<tr class="separator:ga96b0cd3bf0e3d6ae93df93f8673645ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed90cf6c53e6d1efe9a91614c4777c4f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaed90cf6c53e6d1efe9a91614c4777c4f">CSL_EpwmEtIntrPeriod</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggaed90cf6c53e6d1efe9a91614c4777c4fa633ad98c15007c97aa871080b704b907">CSL_EPWM_ET_INTR_PERIOD_DIS_INTR</a> = PWMSS_EPWM_ETPS_INTPRD_DISABLE, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaed90cf6c53e6d1efe9a91614c4777c4fac35bceb1e014ae6e9936d36ddae8d559">CSL_EPWM_ET_INTR_PERIOD_FIRST_EVT</a> = PWMSS_EPWM_ETPS_INTPRD_GEN_FIRST_EVT, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaed90cf6c53e6d1efe9a91614c4777c4fa818626b4ee804b9e45ce7e6aca0ba9f4">CSL_EPWM_ET_INTR_PERIOD_SECOND_EVT</a> = PWMSS_EPWM_ETPS_INTPRD_GEN_SECOND_EVT, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggaed90cf6c53e6d1efe9a91614c4777c4fab3bfddba876ee7c44eb8afafc20c98d3">CSL_EPWM_ET_INTR_PERIOD_THIRD_EVT</a> = PWMSS_EPWM_ETPS_INTPRD_GEN_THIRD_EVT
 }</td></tr>
<tr class="memdesc:gaed90cf6c53e6d1efe9a91614c4777c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ePWM Interrupt (EPWMx_INT) Period Select. These values determine how many selected events need to occur before an interrupt is generated.  <a href="group___c_s_l___e_p_w_m.html#gaed90cf6c53e6d1efe9a91614c4777c4f">More...</a><br /></td></tr>
<tr class="separator:gaed90cf6c53e6d1efe9a91614c4777c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd86ffb64b20b88fe50010c6661dfb0f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gacd86ffb64b20b88fe50010c6661dfb0f">CSL_EpwmHrDelayBusSel</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggacd86ffb64b20b88fe50010c6661dfb0fab74966059dae6f0ef3955486fffeca06">CSL_EPWM_HR_DELAY_BUS_SEL_CMPAHR</a> = PWMSS_EPWM_HRCTL_DELBUSSEL_SEL_CMPAHR, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggacd86ffb64b20b88fe50010c6661dfb0fa780ee7a9be2399269ccd8d5d5fc7f9a3">CSL_EPWM_HR_DELAY_BUS_SEL_TBPHSHR</a> = PWMSS_EPWM_HRCTL_DELBUSSEL_SEL_TBPHSHR
 }</td></tr>
<tr class="memdesc:gacd86ffb64b20b88fe50010c6661dfb0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay Bus Selection, that selects which bus is used to select the delay for the PWM pulse.  <a href="group___c_s_l___e_p_w_m.html#gacd86ffb64b20b88fe50010c6661dfb0f">More...</a><br /></td></tr>
<tr class="separator:gacd86ffb64b20b88fe50010c6661dfb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae843cd74e089d1082a6b9a6cf99cc8cc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae843cd74e089d1082a6b9a6cf99cc8cc">CSL_EpwmHrDelayEdgeCtrl</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggae843cd74e089d1082a6b9a6cf99cc8cca161e80c0c01327565bd14d4d237dd7c0">CSL_EPWM_HR_DELAY_EDGE_CTRL_NO_DELAY</a> = PWMSS_EPWM_HRCTL_DELMODE_NO_DELAY, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggae843cd74e089d1082a6b9a6cf99cc8cca6ff0a5ad631bdcda272f5d9c90763fae">CSL_EPWM_HR_DELAY_EDGE_CTRL_RISING</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggae843cd74e089d1082a6b9a6cf99cc8cca33c4b38f719aa038046022173c86da25">CSL_EPWM_HR_DELAY_EDGE_CTRL_FALLING</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggae843cd74e089d1082a6b9a6cf99cc8cca3de62fa126eb1bfdbfa91e080f5bac8a">CSL_EPWM_HR_DELAY_EDGE_CTRL_BOTH</a>
 }</td></tr>
<tr class="memdesc:gae843cd74e089d1082a6b9a6cf99cc8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delay Mode Configuration, that selects which edge of the PWM pulse the delay is inserted.  <a href="group___c_s_l___e_p_w_m.html#gae843cd74e089d1082a6b9a6cf99cc8cc">More...</a><br /></td></tr>
<tr class="separator:gae843cd74e089d1082a6b9a6cf99cc8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67e0340fa97724992f320582e9d4ff9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad67e0340fa97724992f320582e9d4ff9">CSL_EpwmHrRegActLoad</a> { <a class="el" href="group___c_s_l___e_p_w_m.html#ggad67e0340fa97724992f320582e9d4ff9a54a69205d13c3879fa5d8fe925c594c6">CSL_EPWM_HR_REG_ACT_LOAD_CNT_ZRO_PULSE</a>, 
<a class="el" href="group___c_s_l___e_p_w_m.html#ggad67e0340fa97724992f320582e9d4ff9ac8f00d7fd57c80f168ba3d2ead37bfdd">CSL_EPWM_HR_REG_ACT_LOAD_PRD_EQ_PULSE</a>
 }</td></tr>
<tr class="memdesc:gad67e0340fa97724992f320582e9d4ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pulse selection, that selects which pulse to use for timing events in the HRPWM module.  <a href="group___c_s_l___e_p_w_m.html#gad67e0340fa97724992f320582e9d4ff9">More...</a><br /></td></tr>
<tr class="separator:gad67e0340fa97724992f320582e9d4ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaccc86de57b0138e374b106003c07fdf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaccc86de57b0138e374b106003c07fdf6">CSL_epwmTbTimebaseClkCfg</a> (uint32_t baseAddr, uint32_t tbClk, uint32_t moduleClk)</td></tr>
<tr class="memdesc:gaccc86de57b0138e374b106003c07fdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the clock divider of the Time base module.  <a href="#gaccc86de57b0138e374b106003c07fdf6">More...</a><br /></td></tr>
<tr class="separator:gaccc86de57b0138e374b106003c07fdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa6c5056eb541841419c7e6a3160717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1fa6c5056eb541841419c7e6a3160717">CSL_epwmTbPwmFreqCfg</a> (uint32_t baseAddr, uint32_t tbClk, uint32_t pwmFreq, uint32_t counterDir, uint32_t enableShadowWrite)</td></tr>
<tr class="memdesc:ga1fa6c5056eb541841419c7e6a3160717"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the PWM Time base counter Frequency/Period.  <a href="#ga1fa6c5056eb541841419c7e6a3160717">More...</a><br /></td></tr>
<tr class="separator:ga1fa6c5056eb541841419c7e6a3160717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94a7f77c01cb831a7935fdfd6e766091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga94a7f77c01cb831a7935fdfd6e766091">CSL_epwmTbSyncEnable</a> (uint32_t baseAddr, uint32_t tbPhsValue, uint32_t counterDir)</td></tr>
<tr class="memdesc:ga94a7f77c01cb831a7935fdfd6e766091"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the synchronization of time base sub-module and also configures the phase count value to be loaded after sync event, counter direction after sync event.  <a href="#ga94a7f77c01cb831a7935fdfd6e766091">More...</a><br /></td></tr>
<tr class="separator:ga94a7f77c01cb831a7935fdfd6e766091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f4c56932cad3819d7cc735c4695fd28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga8f4c56932cad3819d7cc735c4695fd28">CSL_epwmTbSyncDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga8f4c56932cad3819d7cc735c4695fd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the synchronization. Even if sync-in event occurs the count value will not be reloaded.  <a href="#ga8f4c56932cad3819d7cc735c4695fd28">More...</a><br /></td></tr>
<tr class="separator:ga8f4c56932cad3819d7cc735c4695fd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1783f1d4e175c768ed350467659065ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1783f1d4e175c768ed350467659065ca">CSL_epwmTbSetSyncOutMode</a> (uint32_t baseAddr, uint32_t syncOutMode)</td></tr>
<tr class="memdesc:ga1783f1d4e175c768ed350467659065ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API selects the source of the synchronization output signal. It determines on which of the supported events sync-out has to be generated.  <a href="#ga1783f1d4e175c768ed350467659065ca">More...</a><br /></td></tr>
<tr class="separator:ga1783f1d4e175c768ed350467659065ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b88fd8c50ffc905cea62f8bf9dc1598"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga9b88fd8c50ffc905cea62f8bf9dc1598">CSL_epwmTbTriggerSwSync</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga9b88fd8c50ffc905cea62f8bf9dc1598"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API generates software triggered sync pulse.  <a href="#ga9b88fd8c50ffc905cea62f8bf9dc1598">More...</a><br /></td></tr>
<tr class="separator:ga9b88fd8c50ffc905cea62f8bf9dc1598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3602d386ffb1b55d7cb6660e5b878d8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga3602d386ffb1b55d7cb6660e5b878d8c">CSL_epwmTbWriteTbCount</a> (uint32_t baseAddr, uint32_t tbCount)</td></tr>
<tr class="memdesc:ga3602d386ffb1b55d7cb6660e5b878d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API loads the Time base counter. The new value is taken immediately.  <a href="#ga3602d386ffb1b55d7cb6660e5b878d8c">More...</a><br /></td></tr>
<tr class="separator:ga3602d386ffb1b55d7cb6660e5b878d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3debb795a5a3c567ff4a5f6f2fb3a564"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga3debb795a5a3c567ff4a5f6f2fb3a564">CSL_epwmTbReadTbCount</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga3debb795a5a3c567ff4a5f6f2fb3a564"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the Time base counter current value. The count operation is not affected by the read.  <a href="#ga3debb795a5a3c567ff4a5f6f2fb3a564">More...</a><br /></td></tr>
<tr class="separator:ga3debb795a5a3c567ff4a5f6f2fb3a564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7071efede364ce48b46fcc63ed44c325"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7071efede364ce48b46fcc63ed44c325">CSL_epwmTbGetStatus</a> (uint32_t baseAddr, uint32_t tbStatusMask)</td></tr>
<tr class="memdesc:ga7071efede364ce48b46fcc63ed44c325"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API gets the Time Base status as indicated by the tbStatusMask parameter.  <a href="#ga7071efede364ce48b46fcc63ed44c325">More...</a><br /></td></tr>
<tr class="separator:ga7071efede364ce48b46fcc63ed44c325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00629ad2136740cb2fc5a5ac3db12d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga00629ad2136740cb2fc5a5ac3db12d1b">CSL_epwmTbStatusClear</a> (uint32_t baseAddr, uint32_t tbStatusClrMask)</td></tr>
<tr class="memdesc:ga00629ad2136740cb2fc5a5ac3db12d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the Time base status bits indicated by the tbStatusClrMask parameter.  <a href="#ga00629ad2136740cb2fc5a5ac3db12d1b">More...</a><br /></td></tr>
<tr class="separator:ga00629ad2136740cb2fc5a5ac3db12d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefe04ef2e88a21414b917aa167c68407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaefe04ef2e88a21414b917aa167c68407">CSL_epwmTbSetEmulationMode</a> (uint32_t baseAddr, uint32_t mode)</td></tr>
<tr class="memdesc:gaefe04ef2e88a21414b917aa167c68407"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures emulation mode. This setting determines the behaviour of Timebase counter during emulation (debugging).  <a href="#gaefe04ef2e88a21414b917aa167c68407">More...</a><br /></td></tr>
<tr class="separator:gaefe04ef2e88a21414b917aa167c68407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbfb18a2d74589338daee3a6a134755c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gabbfb18a2d74589338daee3a6a134755c">CSL_epwmCounterComparatorCfg</a> (uint32_t baseAddr, uint32_t cmpType, uint32_t cmpVal, uint32_t enableShadowWrite, uint32_t shadowToActiveLoadTrigger, uint32_t overwriteShadow)</td></tr>
<tr class="memdesc:gabbfb18a2d74589338daee3a6a134755c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the counter comparator and loads the comparator value. When Counter comparator value equals the counter value, then an event is generated both in the up direction and down direction.  <a href="#gabbfb18a2d74589338daee3a6a134755c">More...</a><br /></td></tr>
<tr class="separator:gabbfb18a2d74589338daee3a6a134755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fc5067aa5e5a90ee10b896dd912a7d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga1fc5067aa5e5a90ee10b896dd912a7d2">CSL_epwmAqActionOnOutputCfg</a> (uint32_t baseAddr, uint32_t pwmOutputCh, const <a class="el" href="group___c_s_l___e_p_w_m.html#gaaa3bc020da4d3d9c9c13d5259e44e2ad">CSL_EpwmAqActionCfg_t</a> *pCfg)</td></tr>
<tr class="memdesc:ga1fc5067aa5e5a90ee10b896dd912a7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the action to be taken on output by the Action qualifier module upon receiving the events. This will determine the output waveform.  <a href="#ga1fc5067aa5e5a90ee10b896dd912a7d2">More...</a><br /></td></tr>
<tr class="separator:ga1fc5067aa5e5a90ee10b896dd912a7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94dcc6812f81713d1de771192f25996f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga94dcc6812f81713d1de771192f25996f">CSL_epwmAqSwTriggerOneTimeAction</a> (uint32_t baseAddr, uint32_t pwmOutputCh, uint32_t swTrigAction)</td></tr>
<tr class="memdesc:ga94dcc6812f81713d1de771192f25996f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API triggers the SW forced single event on the PWM output.  <a href="#ga94dcc6812f81713d1de771192f25996f">More...</a><br /></td></tr>
<tr class="separator:ga94dcc6812f81713d1de771192f25996f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab659bf7153e07a716955b1041a83b7e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab659bf7153e07a716955b1041a83b7e0">CSL_epwmAqSwTriggerContAction</a> (uint32_t baseAddr, uint32_t pwmOutputCh, uint32_t swTrigAction, uint32_t activeRegReloadMode)</td></tr>
<tr class="memdesc:gab659bf7153e07a716955b1041a83b7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API forces output value continuously on PWM output channel. The output can be forced to low or high.  <a href="#gab659bf7153e07a716955b1041a83b7e0">More...</a><br /></td></tr>
<tr class="separator:gab659bf7153e07a716955b1041a83b7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c5cc1dc58a505405457936ad6f39042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0c5cc1dc58a505405457936ad6f39042">CSL_epwmDeadbandCfg</a> (uint32_t baseAddr, const <a class="el" href="group___c_s_l___e_p_w_m.html#gad4201245ce28a464ac9e1493d06f19f9">CSL_EpwmDeadbandCfg_t</a> *pCfg)</td></tr>
<tr class="memdesc:ga0c5cc1dc58a505405457936ad6f39042"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API performs the configuration of the dead band sub-module. This API configures the input source, output mode, polarity, rising and falling edge delays.  <a href="#ga0c5cc1dc58a505405457936ad6f39042">More...</a><br /></td></tr>
<tr class="separator:ga0c5cc1dc58a505405457936ad6f39042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab645593e6d1a96dfabe0abe10123c067"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab645593e6d1a96dfabe0abe10123c067">CSL_epwmDeadbandBypass</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gab645593e6d1a96dfabe0abe10123c067"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API bypasses the Dead-band sub-module.  <a href="#gab645593e6d1a96dfabe0abe10123c067">More...</a><br /></td></tr>
<tr class="separator:gab645593e6d1a96dfabe0abe10123c067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12f7f88391a3459181789d911f8184b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae12f7f88391a3459181789d911f8184b">CSL_epwmChopperCfg</a> (uint32_t baseAddr, const <a class="el" href="group___c_s_l___e_p_w_m.html#ga494e3bbf20e23cebda4ffb422961c7ba">CSL_EpwmChopperCfg_t</a> *pCfg)</td></tr>
<tr class="memdesc:gae12f7f88391a3459181789d911f8184b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API performs the configuration of the chopper sub-module. This API configures chopping clock duty cycle, chopping clock frequency and pulse width of first pulse of chopping clock.  <a href="#gae12f7f88391a3459181789d911f8184b">More...</a><br /></td></tr>
<tr class="separator:gae12f7f88391a3459181789d911f8184b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04dd41f4f5a88637ec8927237ee5b14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga04dd41f4f5a88637ec8927237ee5b14c">CSL_epwmChopperEnable</a> (uint32_t baseAddr, uint32_t enableChopper)</td></tr>
<tr class="memdesc:ga04dd41f4f5a88637ec8927237ee5b14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API controls the enabling or disabling of chopper sub-module.  <a href="#ga04dd41f4f5a88637ec8927237ee5b14c">More...</a><br /></td></tr>
<tr class="separator:ga04dd41f4f5a88637ec8927237ee5b14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65025ed62bdb842f6a520c83a7cfac19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga65025ed62bdb842f6a520c83a7cfac19">CSL_epwmTzTriggerTripAction</a> (uint32_t baseAddr, uint32_t tripAction, uint32_t pwmOutputCh)</td></tr>
<tr class="memdesc:ga65025ed62bdb842f6a520c83a7cfac19"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the o/p on PWM channel when a trip event is recognized. The output can be set to high or low or high impedance.  <a href="#ga65025ed62bdb842f6a520c83a7cfac19">More...</a><br /></td></tr>
<tr class="separator:ga65025ed62bdb842f6a520c83a7cfac19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a425c0124749de1ab5e877f2f529491"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga7a425c0124749de1ab5e877f2f529491">CSL_epwmTzTripEventEnable</a> (uint32_t baseAddr, uint32_t tzEventType, uint32_t pinNum)</td></tr>
<tr class="memdesc:ga7a425c0124749de1ab5e877f2f529491"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the trip event.  <a href="#ga7a425c0124749de1ab5e877f2f529491">More...</a><br /></td></tr>
<tr class="separator:ga7a425c0124749de1ab5e877f2f529491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2360ef51b088052085727d89752bb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga0b2360ef51b088052085727d89752bb9">CSL_epwmTzTripEventDisable</a> (uint32_t baseAddr, uint32_t tzEventType, uint32_t pinNum)</td></tr>
<tr class="memdesc:ga0b2360ef51b088052085727d89752bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disable the trip event. The disabled trip events will be ignored.  <a href="#ga0b2360ef51b088052085727d89752bb9">More...</a><br /></td></tr>
<tr class="separator:ga0b2360ef51b088052085727d89752bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga174736f224abc925a0474a5ee48c5552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga174736f224abc925a0474a5ee48c5552">CSL_epwmTzIntrEnable</a> (uint32_t baseAddr, uint32_t tzEventType)</td></tr>
<tr class="memdesc:ga174736f224abc925a0474a5ee48c5552"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the trip interrupt. When trip event occurs the sub-module can be configured to interrupt CPU.  <a href="#ga174736f224abc925a0474a5ee48c5552">More...</a><br /></td></tr>
<tr class="separator:ga174736f224abc925a0474a5ee48c5552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea8cead002b55aad5f7346e1a192cbba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaea8cead002b55aad5f7346e1a192cbba">CSL_epwmTzIntrDisable</a> (uint32_t baseAddr, uint32_t tzEventType)</td></tr>
<tr class="memdesc:gaea8cead002b55aad5f7346e1a192cbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the trip interrupt.  <a href="#gaea8cead002b55aad5f7346e1a192cbba">More...</a><br /></td></tr>
<tr class="separator:gaea8cead002b55aad5f7346e1a192cbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae33ecda8dfa28260ef573327fd1e0822"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae33ecda8dfa28260ef573327fd1e0822">CSL_epwmTzEventStatus</a> (uint32_t baseAddr, uint32_t eventMask)</td></tr>
<tr class="memdesc:gae33ecda8dfa28260ef573327fd1e0822"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the selected trip zone event status.  <a href="#gae33ecda8dfa28260ef573327fd1e0822">More...</a><br /></td></tr>
<tr class="separator:gae33ecda8dfa28260ef573327fd1e0822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76cff74a105d8bbd78350d8f1367dc86"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga76cff74a105d8bbd78350d8f1367dc86">CSL_epwmTzEventStatusClear</a> (uint32_t baseAddr, uint32_t eventMask)</td></tr>
<tr class="memdesc:ga76cff74a105d8bbd78350d8f1367dc86"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the selected trip zone event status.  <a href="#ga76cff74a105d8bbd78350d8f1367dc86">More...</a><br /></td></tr>
<tr class="separator:ga76cff74a105d8bbd78350d8f1367dc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad424481c3b6ba56fd734c942efd81075"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gad424481c3b6ba56fd734c942efd81075">CSL_epwmTzTriggerSwEvent</a> (uint32_t baseAddr, uint32_t tzEventType)</td></tr>
<tr class="memdesc:gad424481c3b6ba56fd734c942efd81075"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables to generate Software forced trip condition.  <a href="#gad424481c3b6ba56fd734c942efd81075">More...</a><br /></td></tr>
<tr class="separator:gad424481c3b6ba56fd734c942efd81075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74eb5ae3c209861ea82d0ed0fdc7f470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga74eb5ae3c209861ea82d0ed0fdc7f470">CSL_epwmEtIntrCfg</a> (uint32_t baseAddr, uint32_t intrEvtSrc, uint32_t intrPrd)</td></tr>
<tr class="memdesc:ga74eb5ae3c209861ea82d0ed0fdc7f470"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures the Event Trigger sub-module. This API configures the interrupt source and interrupt period.  <a href="#ga74eb5ae3c209861ea82d0ed0fdc7f470">More...</a><br /></td></tr>
<tr class="separator:ga74eb5ae3c209861ea82d0ed0fdc7f470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae500d137bbc0d0fdfc2586081f68f24d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae500d137bbc0d0fdfc2586081f68f24d">CSL_epwmEtIntrEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gae500d137bbc0d0fdfc2586081f68f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API enables the ePWM Event interrupt.  <a href="#gae500d137bbc0d0fdfc2586081f68f24d">More...</a><br /></td></tr>
<tr class="separator:gae500d137bbc0d0fdfc2586081f68f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13e5ad7cd49e5b96face61a0a9258f27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga13e5ad7cd49e5b96face61a0a9258f27">CSL_epwmEtIntrDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga13e5ad7cd49e5b96face61a0a9258f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the ePWM Event interrupt.  <a href="#ga13e5ad7cd49e5b96face61a0a9258f27">More...</a><br /></td></tr>
<tr class="separator:ga13e5ad7cd49e5b96face61a0a9258f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c3da844c980fb123495fa49b1b0657c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga5c3da844c980fb123495fa49b1b0657c">CSL_epwmEtIntrStatus</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga5c3da844c980fb123495fa49b1b0657c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the ePWM event interrupt status.  <a href="#ga5c3da844c980fb123495fa49b1b0657c">More...</a><br /></td></tr>
<tr class="separator:ga5c3da844c980fb123495fa49b1b0657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac24fe4e9590ee1541fcba7291c4d723e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac24fe4e9590ee1541fcba7291c4d723e">CSL_epwmEtIntrClear</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gac24fe4e9590ee1541fcba7291c4d723e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API clears the interrupt. This will clear the interrupt flag bit and enable further interrupts pulses to be generated.  <a href="#gac24fe4e9590ee1541fcba7291c4d723e">More...</a><br /></td></tr>
<tr class="separator:gac24fe4e9590ee1541fcba7291c4d723e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae17259d0151ecfee6757522aab0b4495"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gae17259d0151ecfee6757522aab0b4495">CSL_epwmEtIntrTrigger</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gae17259d0151ecfee6757522aab0b4495"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API forces interrupt to be generated. This API is used for testing purpose.  <a href="#gae17259d0151ecfee6757522aab0b4495">More...</a><br /></td></tr>
<tr class="separator:gae17259d0151ecfee6757522aab0b4495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c2bd0a2f385993fb695645bd6c3d25e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga4c2bd0a2f385993fb695645bd6c3d25e">CSL_epwmEtGetEventCount</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga4c2bd0a2f385993fb695645bd6c3d25e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API returns the number of events occurred.  <a href="#ga4c2bd0a2f385993fb695645bd6c3d25e">More...</a><br /></td></tr>
<tr class="separator:ga4c2bd0a2f385993fb695645bd6c3d25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ff5ba3d8875103bcf78f4a5805728d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gab9ff5ba3d8875103bcf78f4a5805728d">CSL_epwmHighResolutionCfg</a> (uint32_t baseAddr, uint32_t ctrlMode, uint32_t mepCtrlEdge)</td></tr>
<tr class="memdesc:gab9ff5ba3d8875103bcf78f4a5805728d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API configures control mode and edge mode of high resolution sub-module. In also enables the HR sub-module.  <a href="#gab9ff5ba3d8875103bcf78f4a5805728d">More...</a><br /></td></tr>
<tr class="separator:gab9ff5ba3d8875103bcf78f4a5805728d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b6c9b6b308290a2b0f47b437d447f9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga2b6c9b6b308290a2b0f47b437d447f9a">CSL_epwmHrLoadTbPhaseHrValue</a> (uint32_t baseAddr, uint32_t tbPhsHighResVal)</td></tr>
<tr class="memdesc:ga2b6c9b6b308290a2b0f47b437d447f9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API loads the Timebase Phase high resolution register value.  <a href="#ga2b6c9b6b308290a2b0f47b437d447f9a">More...</a><br /></td></tr>
<tr class="separator:ga2b6c9b6b308290a2b0f47b437d447f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe35535163f5e72300c3d6add88d634b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gafe35535163f5e72300c3d6add88d634b">CSL_epwmHrLoadCmpAHrValue</a> (uint32_t baseAddr, uint32_t compAHighResVal, uint32_t ShadowToActiveLoadTrigger)</td></tr>
<tr class="memdesc:gafe35535163f5e72300c3d6add88d634b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API loads Counter-Comparator A high resolution value and also configure the pulse select bits, that select which pulse to use for timing events in the HRPWM module.  <a href="#gafe35535163f5e72300c3d6add88d634b">More...</a><br /></td></tr>
<tr class="separator:gafe35535163f5e72300c3d6add88d634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf038e58613cb1f2bdc693540a66d4a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gaaf038e58613cb1f2bdc693540a66d4a7">CSL_epwmHighResolutionDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gaaf038e58613cb1f2bdc693540a66d4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API disables the high-resolution feature of ePWM.  <a href="#gaaf038e58613cb1f2bdc693540a66d4a7">More...</a><br /></td></tr>
<tr class="separator:gaaf038e58613cb1f2bdc693540a66d4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f858a36044cd3052f6e4fd7e3dd73dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#ga8f858a36044cd3052f6e4fd7e3dd73dd">CSL_epwmClockEnable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:ga8f858a36044cd3052f6e4fd7e3dd73dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions enables clock for EPWM module in PWM subsystem.  <a href="#ga8f858a36044cd3052f6e4fd7e3dd73dd">More...</a><br /></td></tr>
<tr class="separator:ga8f858a36044cd3052f6e4fd7e3dd73dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac23f0ca8fa2be253fadfaf43ef0e906c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___e_p_w_m.html#gac23f0ca8fa2be253fadfaf43ef0e906c">CSL_epwmClockDisable</a> (uint32_t baseAddr)</td></tr>
<tr class="memdesc:gac23f0ca8fa2be253fadfaf43ef0e906c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions disables clock for EPWM sub-module in the PWM subsystem.  <a href="#gac23f0ca8fa2be253fadfaf43ef0e906c">More...</a><br /></td></tr>
<tr class="separator:gac23f0ca8fa2be253fadfaf43ef0e906c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga805c562b6cb0b8523e4e2c9eede3a1b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga1a63042470127ffb20ab8d501911118b">CSL_EpwmAqAction</a>  <a class="el" href="group___c_s_l___e_p_w_m.html#ga805c562b6cb0b8523e4e2c9eede3a1b4">CSL_EpwmAqAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of Actions that Action Qualifier can take on the Output when the supported counter compare event occurs. </p>
<p>Same actions will be applicable for all the supported events and same actions are applicable for both A and B channel PWM outputs.</p>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for all the events and for both A and B because their field values are same.<ul>
<li>Action Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_PRD_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CAU_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CAD_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CBU_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CBD_DISABLED</li>
</ul>
</li>
<li>Action high macros with value 0x1<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_PRD_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CAU_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CAD_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CBU_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CBD_CLEAR</li>
</ul>
</li>
<li>Action low macros with value 0x2<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_SET</li>
<li>PWMSS_EPWM_AQCTLx_PRD_SET</li>
<li>PWMSS_EPWM_AQCTLx_CAU_SET</li>
<li>PWMSS_EPWM_AQCTLx_CAD_SET</li>
<li>PWMSS_EPWM_AQCTLx_CBU_SET</li>
<li>PWMSS_EPWM_AQCTLx_CBD_SET</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_PRD_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CAU_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CAD_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CBU_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CBD_TOGGLE </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga31c16860974e7b6a52688da47566539c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga99aefc353ef1392b47281d6096610fbe">CSL_EpwmAqSwTrigContAction</a>  <a class="el" href="group___c_s_l___e_p_w_m.html#ga31c16860974e7b6a52688da47566539c">CSL_EpwmAqSwTrigContAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of Continuous software forced actions on output. </p>
<p>Same macros will be used for configuration of both A and B PWM outputs, because bit field values for both A and B are same.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros,<ul>
<li>Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_DISABLED</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_DISABLED</li>
</ul>
</li>
<li>Action low macros with value 0x1<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_LOW_OUTPUT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_LOW_OUTPUT</li>
</ul>
</li>
<li>Action high macros with value 0x2<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_HIGH_OUTPUT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_HIGH_OUTPUT</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_NO_EFFECT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_NO_EFFECT </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae5436d5c1b122f8d49b6702f2d5e88cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga6e78c68e4d7bd43886e3f2e794677599">CSL_EpwmAqSwTrigOtAction</a>  <a class="el" href="group___c_s_l___e_p_w_m.html#gae5436d5c1b122f8d49b6702f2d5e88cc">CSL_EpwmAqSwTrigOtAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actions to be taken on the output, when Software triggered one time events will occur. </p>
<p>Same macros will be used for both A and B channel outputs because the bit field values are same.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros,<ul>
<li>Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_DISABLED</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_DISABLED</li>
</ul>
</li>
<li>Action low macros with value 0x1<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_CLEAR</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_CLEAR</li>
</ul>
</li>
<li>Action high macros with value 0x2<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_SET</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_SET</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_TOGGLE</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_TOGGLE </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga4095133466d3bd0f770d832c0c671f5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaf1e0c12be0466807de968eacfa1d2305">CSL_EpwmCcCmp</a>  <a class="el" href="group___c_s_l___e_p_w_m.html#ga4095133466d3bd0f770d832c0c671f5d">CSL_EpwmCcCmp_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\ Counter Comparator type either A or B. </p>

</div>
</div>
<a class="anchor" id="gaa49bb59c3a7915b1715fd9bdf453072e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gabafad0ffb4ff526bd6f728f8e3f4b943">CSL_EpwmCcCmpLoadMode</a>  <a class="el" href="group___c_s_l___e_p_w_m.html#gaa49bb59c3a7915b1715fd9bdf453072e">CSL_EpwmCcCmpLoadMode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter-Comparator registers(A and B) load mode flags from shadow register. </p>
<p>Same macros will be used to control the following registers</p><ul>
<li>Counter Comparator A register</li>
<li>Counter Comparator B register</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for controlling all the three registers because the field values are same for all these cases.<ul>
<li>load when counter equals zero = 0x0</li>
<li>load when counter equals period = 0x1</li>
<li>load when counter equals zero or period = 0x2</li>
<li>Do not load = 0x3 In any case if these values changes across the above mentioned registers, then separate macros need to be used.</li>
<li>Load when counter equals zero macros with value 0x0<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0,</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_0,</li>
</ul>
</li>
<li>Load when counter equals period macros with value 0x1<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_PRD</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_PRD</li>
</ul>
</li>
<li>Load when counter equals zero or period macros with value 0x2<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0_OR_PRD</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_0_OR_PRD</li>
</ul>
</li>
<li>Do not load macros with value 0x3<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_FREEZE</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_FREEZE </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6f7a09a63c915d6a04097a58b4af1008"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga94bff6472785045fba9b46f3d3d60890">CSL_EpwmShadowRegCtrl</a>  <a class="el" href="group___c_s_l___e_p_w_m.html#ga6f7a09a63c915d6a04097a58b4af1008">CSL_EpwmShadowRegCtrl_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow register enable or disable control. </p>
<p>Same macros will be used to control the following shadow registers</p><ul>
<li>Time Base period register</li>
<li>Counter Comparator A register</li>
<li>Counter Comparator B register</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for controlling all the three registers because the field values are same for all these cases.<ul>
<li>Shadow enable = 0x0</li>
<li>Shadow disable = 0x1 In any case if these values changes across the above mentioned registers then separate macros need to be used.</li>
<li>Shadow enable macros with value 0x0<ul>
<li>PWMSS_EPWM_TBCTL_PRDLD_LOAD_FROM_SHADOW,</li>
<li>PWMSS_EPWM_CMPCTL_SHDWAMODE_SHADOW,</li>
<li>PWMSS_EPWM_CMPCTL_SHDWBMODE_SHADOW</li>
</ul>
</li>
<li>Shadow disable macros with value 0x1<ul>
<li>PWMSS_EPWM_TBCTL_PRDLD_LOAD_IMMEDIATELY</li>
<li>PWMSS_EPWM_CMPCTL_SHDWAMODE_IMMEDIATE</li>
<li>PWMSS_EPWM_CMPCTL_SHDWBMODE_IMMEDIATE </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga6bf2f55aca379fc7846538bed71ef049"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaa9c1aa65bb06a11eefbd84871d3deeb2">CSL_EpwmTzTripAction</a>  <a class="el" href="group___c_s_l___e_p_w_m.html#ga6bf2f55aca379fc7846538bed71ef049">CSL_EpwmTzTripAction_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Action to be taken on PWM output When a trip event occurs. </p>
<p>Same macros will be used to control both A and B outputs because the bit field values are same for A and B channels.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros<ul>
<li>Tri state action macro with value 0x0<ul>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_IMPEDANCE</li>
<li>PWMSS_EPWM_TZCTL_TZB_HIGH_IMPEDANCE</li>
</ul>
</li>
<li>High action macro with value 0x1<ul>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_STATE</li>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_STATE</li>
</ul>
</li>
<li>Low action macro with value 0x2<ul>
<li>PWMSS_EPWM_TZCTL_TZA_LOW_STATE</li>
<li>PWMSS_EPWM_TZCTL_TZB_LOW_STATE</li>
</ul>
</li>
<li>Do nothing action macro with value 0x3<ul>
<li>PWMSS_EPWM_TZCTL_TZA_DO_NOTHING</li>
<li>PWMSS_EPWM_TZCTL_TZB_DO_NOTHING </li>
</ul>
</li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga1a63042470127ffb20ab8d501911118b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga1a63042470127ffb20ab8d501911118b">CSL_EpwmAqAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of Actions that Action Qualifier can take on the Output when the supported counter compare event occurs. </p>
<p>Same actions will be applicable for all the supported events and same actions are applicable for both A and B channel PWM outputs.</p>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for all the events and for both A and B because their field values are same.<ul>
<li>Action Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_PRD_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CAU_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CAD_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CBU_DISABLED</li>
<li>PWMSS_EPWM_AQCTLx_CBD_DISABLED</li>
</ul>
</li>
<li>Action high macros with value 0x1<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_PRD_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CAU_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CAD_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CBU_CLEAR</li>
<li>PWMSS_EPWM_AQCTLx_CBD_CLEAR</li>
</ul>
</li>
<li>Action low macros with value 0x2<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_SET</li>
<li>PWMSS_EPWM_AQCTLx_PRD_SET</li>
<li>PWMSS_EPWM_AQCTLx_CAU_SET</li>
<li>PWMSS_EPWM_AQCTLx_CAD_SET</li>
<li>PWMSS_EPWM_AQCTLx_CBU_SET</li>
<li>PWMSS_EPWM_AQCTLx_CBD_SET</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQCTLx_ZRO_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_PRD_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CAU_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CAD_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CBU_TOGGLE</li>
<li>PWMSS_EPWM_AQCTLx_CBD_TOGGLE </li>
</ul>
</li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga1a63042470127ffb20ab8d501911118ba34260a2cfbf91b3c24465eadbb9cb0eb"></a>CSL_EPWM_AQ_ACTION_DONOTHING&#160;</td><td class="fielddoc">
<p>Do nothing (Action disabled). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1a63042470127ffb20ab8d501911118bad7641d7629a601262885f6f2068c78e9"></a>CSL_EPWM_AQ_ACTION_LOW&#160;</td><td class="fielddoc">
<p>Clear: Force EPWMx output low. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1a63042470127ffb20ab8d501911118bac79689946ad100f315daa07aa15f12fa"></a>CSL_EPWM_AQ_ACTION_HIGH&#160;</td><td class="fielddoc">
<p>Set: Force EPWMx output high. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga1a63042470127ffb20ab8d501911118ba378ee34781b778fe278056770e7fb455"></a>CSL_EPQM_AQ_ACTION_TOLLGE&#160;</td><td class="fielddoc">
<p>Toggle EPWMx output: low output signal will be forced high, and a high signal will be forced low. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf31be2041e0e3d8ee980bc3286bd824d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaf31be2041e0e3d8ee980bc3286bd824d">CSL_EpwmAqCsfrcRegReload</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Action Qualifier Software Force Active Register Reload From Shadow Options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf31be2041e0e3d8ee980bc3286bd824da9115a85d3dd16e591982a03af69d0792"></a>CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_ZRO&#160;</td><td class="fielddoc">
<p>Load on event counter equals zero. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf31be2041e0e3d8ee980bc3286bd824daac7d5425ffe30e01c40fabf774eb2764"></a>CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_PRD&#160;</td><td class="fielddoc">
<p>Load on event counter equals period. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf31be2041e0e3d8ee980bc3286bd824daa5e7b5cef264bb6f523775b2a256b9c0"></a>CSL_EPWM_AQ_CSFRC_REG_RELOAD_CNT_EQ_ZRO_OR_PRD&#160;</td><td class="fielddoc">
<p>Load on event counter equals zero or counter equals period. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf31be2041e0e3d8ee980bc3286bd824dac6e7af8180445da77d1e58da52799c73"></a>CSL_EPWM_AQ_CSFRC_REG_RELOAD_IMMEDIATE&#160;</td><td class="fielddoc">
<p>Load immediately. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga99aefc353ef1392b47281d6096610fbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga99aefc353ef1392b47281d6096610fbe">CSL_EpwmAqSwTrigContAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of Continuous software forced actions on output. </p>
<p>Same macros will be used for configuration of both A and B PWM outputs, because bit field values for both A and B are same.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros,<ul>
<li>Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_DISABLED</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_DISABLED</li>
</ul>
</li>
<li>Action low macros with value 0x1<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_LOW_OUTPUT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_LOW_OUTPUT</li>
</ul>
</li>
<li>Action high macros with value 0x2<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_HIGH_OUTPUT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_HIGH_OUTPUT</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQCSFRC_CSFA_NO_EFFECT</li>
<li>PWMSS_EPWM_AQCSFRC_CSFB_NO_EFFECT </li>
</ul>
</li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga99aefc353ef1392b47281d6096610fbeaef9276b60b40a89d347e74aedf340379"></a>CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_NOEFFECT&#160;</td><td class="fielddoc">
<p>Forcing disabled, that is, has no effect. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga99aefc353ef1392b47281d6096610fbeaeb1d0e94acbf6df5c4840cc95298bc25"></a>CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_LOW&#160;</td><td class="fielddoc">
<p>Forces a continuous low on output A. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga99aefc353ef1392b47281d6096610fbea5784c1a23c4f6638e5dc9048f2e182a1"></a>CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_HIGH&#160;</td><td class="fielddoc">
<p>Forces a continuous high on output A. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga99aefc353ef1392b47281d6096610fbea042c0fd5155466407b1adbbe25d174d6"></a>CSL_EPWM_AQ_SW_TRIG_CONT_ACTION_SW_DISBALED&#160;</td><td class="fielddoc">
<p>Software forcing is disabled and has no effect. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga6e78c68e4d7bd43886e3f2e794677599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga6e78c68e4d7bd43886e3f2e794677599">CSL_EpwmAqSwTrigOtAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actions to be taken on the output, when Software triggered one time events will occur. </p>
<p>Same macros will be used for both A and B channel outputs because the bit field values are same.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros,<ul>
<li>Do nothing macros with value 0x0<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_DISABLED</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_DISABLED</li>
</ul>
</li>
<li>Action low macros with value 0x1<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_CLEAR</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_CLEAR</li>
</ul>
</li>
<li>Action high macros with value 0x2<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_SET</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_SET</li>
</ul>
</li>
<li>Action toggle macros with value 0x3<ul>
<li>PWMSS_EPWM_AQSFRC_ACTSFA_TOGGLE</li>
<li>PWMSS_EPWM_AQSFRC_ACTSFB_TOGGLE </li>
</ul>
</li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga6e78c68e4d7bd43886e3f2e794677599af97f3f900f40e1122c76e8e181753de2"></a>CSL_EPWM_AQ_SW_TRIG_OT_ACTION_DONOTHING&#160;</td><td class="fielddoc">
<p>Do nothing (Action disabled). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6e78c68e4d7bd43886e3f2e794677599a50f22b5604eb04263f0c11b63021a806"></a>CSL_EPWM_AQ_SW_TRIG_OT_ACTION_LOW&#160;</td><td class="fielddoc">
<p>Clear: Output Low. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6e78c68e4d7bd43886e3f2e794677599aa6779a86f4d9aa98e5fbc4ffcea60670"></a>CSL_EPWM_AQ_SW_TRIG_OT_ACTION_HIGH&#160;</td><td class="fielddoc">
<p>Set: Output high. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga6e78c68e4d7bd43886e3f2e794677599a523897698aecdcf44cc5c1a2949004f3"></a>CSL_EPWM_AQ_SW_TRIG_OT_ACTION_TOGGLE&#160;</td><td class="fielddoc">
<p>Toggle output. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaf1e0c12be0466807de968eacfa1d2305"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaf1e0c12be0466807de968eacfa1d2305">CSL_EpwmCcCmp</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\ Counter Comparator type either A or B. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaf1e0c12be0466807de968eacfa1d2305a9bc936b046013a9f6e5befdc7666abb2"></a>CSL_EPWM_CC_CMP_MIN&#160;</td><td class="fielddoc">
<p>Minimum value of enumeration. Used for input validation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf1e0c12be0466807de968eacfa1d2305a5c3591e5e90b8e2c807f1624b4808a15"></a>CSL_EPWM_CC_CMP_A&#160;</td><td class="fielddoc">
<p>Counter Comparator A. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf1e0c12be0466807de968eacfa1d2305ad98c40de48f776c939a7bd83a01eab08"></a>CSL_EPWM_CC_CMP_B&#160;</td><td class="fielddoc">
<p>Counter Comparator B. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaf1e0c12be0466807de968eacfa1d2305a5021ed73047ae4c447de600342ad24c6"></a>CSL_EPWM_CC_CMP_MAX&#160;</td><td class="fielddoc">
<p>Maximum value of enumeration. Used for input validation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gabafad0ffb4ff526bd6f728f8e3f4b943"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gabafad0ffb4ff526bd6f728f8e3f4b943">CSL_EpwmCcCmpLoadMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter-Comparator registers(A and B) load mode flags from shadow register. </p>
<p>Same macros will be used to control the following registers</p><ul>
<li>Counter Comparator A register</li>
<li>Counter Comparator B register</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for controlling all the three registers because the field values are same for all these cases.<ul>
<li>load when counter equals zero = 0x0</li>
<li>load when counter equals period = 0x1</li>
<li>load when counter equals zero or period = 0x2</li>
<li>Do not load = 0x3 In any case if these values changes across the above mentioned registers, then separate macros need to be used.</li>
<li>Load when counter equals zero macros with value 0x0<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0,</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_0,</li>
</ul>
</li>
<li>Load when counter equals period macros with value 0x1<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_PRD</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_PRD</li>
</ul>
</li>
<li>Load when counter equals zero or period macros with value 0x2<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_CTR_0_OR_PRD</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_CTR_0_OR_PRD</li>
</ul>
</li>
<li>Do not load macros with value 0x3<ul>
<li>PWMSS_EPWM_CMPCTL_LOADAMODE_FREEZE</li>
<li>PWMSS_EPWM_CMPCTL_LOADBMODE_FREEZE </li>
</ul>
</li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggabafad0ffb4ff526bd6f728f8e3f4b943a778b20673a79f03f39472fe1348b40fc"></a>CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_ZERO&#160;</td><td class="fielddoc">
<p>Load on CTR = 0: Time-base counter equal to zero. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabafad0ffb4ff526bd6f728f8e3f4b943a4bc853357e2880d26981da7c48fbad3a"></a>CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_PRD&#160;</td><td class="fielddoc">
<p>Load on CTR = PRD: Time-base counter equal to period. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabafad0ffb4ff526bd6f728f8e3f4b943a1e2eb6054a67cba5e9c47d29591a79d5"></a>CSL_EPWM_CC_CMP_LOAD_MODE_CNT_EQ_ZERO_OR_PRD&#160;</td><td class="fielddoc">
<p>Load on either CTR = 0 or CTR = PRD. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabafad0ffb4ff526bd6f728f8e3f4b943a99d5bf6e08505f041e676c826c4aee1b"></a>CSL_EPWM_CC_CMP_LOAD_MODE_NO_LOAD&#160;</td><td class="fielddoc">
<p>Freeze (no loads possible). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa268fe53917e58604cee84c2663590db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaa268fe53917e58604cee84c2663590db">CSL_EpwmChpClkFreq</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chopping Clock Frequency values . </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa268fe53917e58604cee84c2663590dba3d1bcfe2784e18c90d247056607c37e3"></a>CSL_EPWM_CHP_CLK_FREQ_DIV_BY_1&#160;</td><td class="fielddoc">
<p>Divide by 1 (no prescale). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa268fe53917e58604cee84c2663590dba40d7772b99f8a1525fdbc185f5af064b"></a>CSL_EPWM_CHP_CLK_FREQ_DIV_BY_2&#160;</td><td class="fielddoc">
<p>Divide by 2. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa268fe53917e58604cee84c2663590dbaf595125ab4cbdc508b1e393acb0cc301"></a>CSL_EPWM_CHP_CLK_FREQ_DIV_BY_3&#160;</td><td class="fielddoc">
<p>Divide by 3. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa268fe53917e58604cee84c2663590dbaf5d1bc9838aa12ec5a8f52e521046e7f"></a>CSL_EPWM_CHP_CLK_FREQ_DIV_BY_4&#160;</td><td class="fielddoc">
<p>Divide by 4. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa268fe53917e58604cee84c2663590dbac45b7640f61a4c56e84727dd518b6da8"></a>CSL_EPWM_CHP_CLK_FREQ_DIV_BY_5&#160;</td><td class="fielddoc">
<p>Divide by 5. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa268fe53917e58604cee84c2663590dbaa18d441e3117466def8df4c64ea27acc"></a>CSL_EPWM_CHP_CLK_FREQ_DIV_BY_6&#160;</td><td class="fielddoc">
<p>Divide by 6. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa268fe53917e58604cee84c2663590dba8bc1f2a61cd6abd2ca9dea5c04e803e4"></a>CSL_EPWM_CHP_CLK_FREQ_DIV_BY_7&#160;</td><td class="fielddoc">
<p>Divide by 7. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa268fe53917e58604cee84c2663590dbabe5f8eb1be0a122bcc589bf462863aeb"></a>CSL_EPWM_CHP_CLK_FREQ_DIV_BY_8&#160;</td><td class="fielddoc">
<p>Divide by 8. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8b68ac038fbf4e0d88bdddcbda0c9c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga8b68ac038fbf4e0d88bdddcbda0c9c42">CSL_EpwmChpDutyCycle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chopping Clock Duty Cycle values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga8b68ac038fbf4e0d88bdddcbda0c9c42a4a11e33a3834d5aebef0823bd9499e4c"></a>CSL_EPWM_CHP_DUTY_CYCLE_PERC_12PNT5&#160;</td><td class="fielddoc">
<p>Duty cycle 1/8 (12.5%). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8b68ac038fbf4e0d88bdddcbda0c9c42aaa4efb096bb1e373891a80b7765e2150"></a>CSL_EPWM_CHP_DUTY_CYCLE_PERC_25&#160;</td><td class="fielddoc">
<p>Duty cycle 2/8 (25%). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8b68ac038fbf4e0d88bdddcbda0c9c42acf6479d385cf06fc8f7de07572b999c2"></a>CSL_EPWM_CHP_DUTY_CYCLE_PERC_37PNT5&#160;</td><td class="fielddoc">
<p>Duty cycle 3/8 (37.5%). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8b68ac038fbf4e0d88bdddcbda0c9c42a42f89670a50959f797e61b82c84563c1"></a>CSL_EPWM_CHP_DUTY_CYCLE_PERC_50_PER&#160;</td><td class="fielddoc">
<p>Duty cycle 4/8 (50%). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8b68ac038fbf4e0d88bdddcbda0c9c42aaa2bbeb82b0dad07ebeb567902566167"></a>CSL_EPWM_CHP_DUTY_CYCLE_PERC_62PNT5&#160;</td><td class="fielddoc">
<p>Duty cycle 5/8 (62.5%). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8b68ac038fbf4e0d88bdddcbda0c9c42ac6e4208f671cbee2a7fa5eaabdf60407"></a>CSL_EPWM_CHP_DUTY_CYCLE_PERC_75&#160;</td><td class="fielddoc">
<p>Duty cycle 6/8 (75%). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga8b68ac038fbf4e0d88bdddcbda0c9c42a43b5ea3980d8a2b4ae4caf4f5ddfbdb2"></a>CSL_EPWM_CHP_DUTY_CYCLE_PERC_87PNT5&#160;</td><td class="fielddoc">
<p>Duty cycle 7/8 (87.5%). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga98e2de17e835f8403866e61589f7d2c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga98e2de17e835f8403866e61589f7d2c7">CSL_EpwmChpOshtWidth</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>One-Shot Pulse Width values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a8f79b82b61abfcd263229112a8c0f912"></a>CSL_EPWM_CHP_OSHT_WIDTH_MIN&#160;</td><td class="fielddoc">
<p>Minimum value of enumeration. Used for input validation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7aacf86b6b93d920972afcb9f963021fb0"></a>CSL_EPWM_CHP_OSHT_WIDTH_1XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>1 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7adacb1080ee930ae88c9018f72fca1ef5"></a>CSL_EPWM_CHP_OSHT_WIDTH_2XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>2 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a46a78b2924c20588287f0518489131e4"></a>CSL_EPWM_CHP_OSHT_WIDTH_3XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>3 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a1990f4acf25fef5def94ab6210ec08d4"></a>CSL_EPWM_CHP_OSHT_WIDTH_4XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>4 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a8672538806780d66de4920f8c9866469"></a>CSL_EPWM_CHP_OSHT_WIDTH_5XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>5 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a0bcaf19b06db46e383ba85c293d9e147"></a>CSL_EPWM_CHP_OSHT_WIDTH_6XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>6 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7afac68f2e7edf22178e53f44f4675aeea"></a>CSL_EPWM_CHP_OSHT_WIDTH_7XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>7 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7acb8f974960a6a5723d2ca962aceeb5d1"></a>CSL_EPWM_CHP_OSHT_WIDTH_8XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>8 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7aff559144eeba54c3efa63e939c516119"></a>CSL_EPWM_CHP_OSHT_WIDTH_9XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>9 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7aff527deb6b19b14a981d761f6f5ad2c0"></a>CSL_EPWM_CHP_OSHT_WIDTH_10XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>10 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a35eace1a36a3894e60678c18c85840d9"></a>CSL_EPWM_CHP_OSHT_WIDTH_11XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>11 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7acfb588cec1406cfec2216503644facec"></a>CSL_EPWM_CHP_OSHT_WIDTH_12XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>12 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a0b28f709de771fbdd01721451e3181aa"></a>CSL_EPWM_CHP_OSHT_WIDTH_13XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>13 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a56a9118a2f1ebc1055654fc2d74d8e83"></a>CSL_EPWM_CHP_OSHT_WIDTH_14XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>14 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a78a0497f468046213591c85d48ed1113"></a>CSL_EPWM_CHP_OSHT_WIDTH_15XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>15 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7a21d257443f329c08d435b00eaab2e6ed"></a>CSL_EPWM_CHP_OSHT_WIDTH_16XSYSOUT_BY_8&#160;</td><td class="fielddoc">
<p>16 x SYSCLKOUT/8 wide. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga98e2de17e835f8403866e61589f7d2c7aa9c2274dca6869141e006ec1b56fe4b1"></a>CSL_EPWM_CHP_OSHT_WIDTH_MAX&#160;</td><td class="fielddoc">
<p>Maximum value of enumeration. Used for input validation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga7f9ad7e313e22da2793af8551a87ec20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga7f9ad7e313e22da2793af8551a87ec20">CSL_EpwmDbInMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dead Band Input Mode Control. This allows you to select the input source to the falling-edge and rising-edge delay. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7f9ad7e313e22da2793af8551a87ec20aa0737d25f6afcd3f969643b89b49ffc4"></a>CSL_EPWM_DB_IN_MODE_A_RED_A_FED&#160;</td><td class="fielddoc">
<p>EPWMxA In (from the action-qualifier) is the source for both falling-edge and rising-edge delay. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7f9ad7e313e22da2793af8551a87ec20ad5ce6b8b7f761059c4098db9acb948eb"></a>CSL_EPWM_DB_IN_MODE_B_RED_A_FED&#160;</td><td class="fielddoc">
<p>EPWMxB In (from the action-qualifier) is the source for rising-edge delayed signal. EPWMxA In (from the action-qualifier) is the source for falling-edge delayed signal. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7f9ad7e313e22da2793af8551a87ec20a3262770536d01acf3292de98a47f9b57"></a>CSL_EPWM_DB_IN_MODE_A_RED_B_FED&#160;</td><td class="fielddoc">
<p>EPWMxA In (from the action-qualifier) is the source for rising-edge delayed signal. EPWMxB In (from the action-qualifier) is the source for falling-edge delayed signal. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7f9ad7e313e22da2793af8551a87ec20a62184f1a9064a37e6793e97654ec6571"></a>CSL_EPWM_DB_IN_MODE_B_RED_B_FED&#160;</td><td class="fielddoc">
<p>EPWMxB In (from the action-qualifier) is the source for both rising-edge delay and falling-edge delayed signal. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga553301c918cd875b997bfc4a5b2a9e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga553301c918cd875b997bfc4a5b2a9e57">CSL_EpwmDbOutMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dead-band Output Mode Control. This allows you to selectively enable or bypass the dead-band generation for the falling-edge and rising-edge delay. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga553301c918cd875b997bfc4a5b2a9e57a26f296641314d0d48cb9b7ce734845f7"></a>CSL_EPWM_DB_OUT_MODE_BYPASS&#160;</td><td class="fielddoc">
<p>Dead-band generation is bypassed for both output signals. In this mode, both the EPWMxA and EPWMxB output signals from the action-qualifier are passed directly to the PWM-chopper sub-module. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga553301c918cd875b997bfc4a5b2a9e57a07a297e8f8278713f4cd0db31a3fedd7"></a>CSL_EPWM_DB_OUT_MODE_NO_RED_B_FED&#160;</td><td class="fielddoc">
<p>Disable rising-edge delay. The EPWMxA signal from the action-qualifier is passed straight through to the EPWMxA input of the PWM-chopper sub-module. The falling-edge delayed signal is seen on output EPWMxB </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga553301c918cd875b997bfc4a5b2a9e57ac1e7e3af71947e310a5ae3c73928548e"></a>CSL_EPWM_DB_OUT_MODE_A_RED_NO_FED&#160;</td><td class="fielddoc">
<p>Disable falling-edge delay. The EPWMxB signal from the action-qualifier is passed straight through to the EPWMxB input of the PWM-chopper sub-module. The rising-edge delayed signal is seen on output EPWMxA. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga553301c918cd875b997bfc4a5b2a9e57ace913a9270f8deeb0a6a364371bfbcdb"></a>CSL_EPWM_DB_OUT_MODE_A_RED_B_FED&#160;</td><td class="fielddoc">
<p>Dead-band is fully enabled for both rising-edge delay on output EPWMxA and falling-edge delay on output EPWMxB. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga93879a1613c7b2d77e60d33a941da960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga93879a1613c7b2d77e60d33a941da960">CSL_EpwmDbPolSel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polarity Select Control. This allows you to selectively invert one of the delayed signals before it is sent out of the dead-band sub-module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga93879a1613c7b2d77e60d33a941da960ab8e242fdbe66d81738dd0ff66bb3da50"></a>CSL_EPWM_DB_POL_SEL_ACTV_HIGH&#160;</td><td class="fielddoc">
<p>Neither EPWMxA nor EPWMxB is inverted (default). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga93879a1613c7b2d77e60d33a941da960ac35aabfd4fbb370b8a6d194c460fab48"></a>CSL_EPWM_DB_POL_SEL_ACTV_LOW_COMPLEMENTARY&#160;</td><td class="fielddoc">
<p>EPWMxA is inverted. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga93879a1613c7b2d77e60d33a941da960a46dac6d1f7e4b1b719d059cf7c9f2bca"></a>CSL_EPWM_DB_POL_SEL_ACTV_HIGH_COMPLEMENTARY&#160;</td><td class="fielddoc">
<p>EPWMxB is inverted. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga93879a1613c7b2d77e60d33a941da960ad2ce86787b92d2281646baa67f83282f"></a>CSL_EPWM_DB_POL_SEL_ACTV_LOW&#160;</td><td class="fielddoc">
<p>Both EPWMxA and EPWMxB are inverted. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga96b0cd3bf0e3d6ae93df93f8673645ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga96b0cd3bf0e3d6ae93df93f8673645ed">CSL_EpwmEtIntrEvt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ePWM Interrupt (EPWMx_INT) Selection Options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga96b0cd3bf0e3d6ae93df93f8673645eda43a5fc4a823dc35ffc64a0c7300dc269"></a>CSL_EPWM_ET_INTR_EVT_CNT_EQ_ZRO&#160;</td><td class="fielddoc">
<p>Enable event time-base counter equal to zero. (TBCNT = 0000h). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga96b0cd3bf0e3d6ae93df93f8673645eda8dc350ef255c9b9e5cbece099fe90968"></a>CSL_EPWM_ET_INTR_EVT_CNT_EQ_PRD&#160;</td><td class="fielddoc">
<p>Enable event time-base counter equal to period (TBCNT = TBPRD). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga96b0cd3bf0e3d6ae93df93f8673645edadc4a44d9c1ad821001e40d22ea15360c"></a>CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPA_INC&#160;</td><td class="fielddoc">
<p>Enable event time-base counter equal to CMPA when the timer is incrementing. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga96b0cd3bf0e3d6ae93df93f8673645edae5ea9b64b51cf79646b684033251714a"></a>CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPA_DEC&#160;</td><td class="fielddoc">
<p>Enable event time-base counter equal to CMPA when the timer is decrementing. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga96b0cd3bf0e3d6ae93df93f8673645eda6d1682dfc79fed7b493906e15ffe991b"></a>CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPB_INC&#160;</td><td class="fielddoc">
<p>Enable event: time-base counter equal to CMPB when the timer is incrementing. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga96b0cd3bf0e3d6ae93df93f8673645eda1edbdd609cb98e6370576a266b967838"></a>CSL_EPWM_ET_INTR_EVT_CNT_EQ_CMPB_DEC&#160;</td><td class="fielddoc">
<p>Enable event: time-base counter equal to CMPB when the timer is decrementing. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaed90cf6c53e6d1efe9a91614c4777c4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaed90cf6c53e6d1efe9a91614c4777c4f">CSL_EpwmEtIntrPeriod</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ePWM Interrupt (EPWMx_INT) Period Select. These values determine how many selected events need to occur before an interrupt is generated. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaed90cf6c53e6d1efe9a91614c4777c4fa633ad98c15007c97aa871080b704b907"></a>CSL_EPWM_ET_INTR_PERIOD_DIS_INTR&#160;</td><td class="fielddoc">
<p>Disable the interrupt event counter. No interrupt will be generated. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaed90cf6c53e6d1efe9a91614c4777c4fac35bceb1e014ae6e9936d36ddae8d559"></a>CSL_EPWM_ET_INTR_PERIOD_FIRST_EVT&#160;</td><td class="fielddoc">
<p>Generate an interrupt on the first event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaed90cf6c53e6d1efe9a91614c4777c4fa818626b4ee804b9e45ce7e6aca0ba9f4"></a>CSL_EPWM_ET_INTR_PERIOD_SECOND_EVT&#160;</td><td class="fielddoc">
<p>Generate an interrupt on the second event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaed90cf6c53e6d1efe9a91614c4777c4fab3bfddba876ee7c44eb8afafc20c98d3"></a>CSL_EPWM_ET_INTR_PERIOD_THIRD_EVT&#160;</td><td class="fielddoc">
<p>Generate an interrupt on the third event. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gacd86ffb64b20b88fe50010c6661dfb0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gacd86ffb64b20b88fe50010c6661dfb0f">CSL_EpwmHrDelayBusSel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay Bus Selection, that selects which bus is used to select the delay for the PWM pulse. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggacd86ffb64b20b88fe50010c6661dfb0fab74966059dae6f0ef3955486fffeca06"></a>CSL_EPWM_HR_DELAY_BUS_SEL_CMPAHR&#160;</td><td class="fielddoc">
<p>Select CMPAHR(8) bus from compare module of EPWM (default on reset). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacd86ffb64b20b88fe50010c6661dfb0fa780ee7a9be2399269ccd8d5d5fc7f9a3"></a>CSL_EPWM_HR_DELAY_BUS_SEL_TBPHSHR&#160;</td><td class="fielddoc">
<p>Select TBPHSHR(8) bus from time base module. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gae843cd74e089d1082a6b9a6cf99cc8cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gae843cd74e089d1082a6b9a6cf99cc8cc">CSL_EpwmHrDelayEdgeCtrl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delay Mode Configuration, that selects which edge of the PWM pulse the delay is inserted. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggae843cd74e089d1082a6b9a6cf99cc8cca161e80c0c01327565bd14d4d237dd7c0"></a>CSL_EPWM_HR_DELAY_EDGE_CTRL_NO_DELAY&#160;</td><td class="fielddoc">
<p>No delay inserted (default on reset). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae843cd74e089d1082a6b9a6cf99cc8cca6ff0a5ad631bdcda272f5d9c90763fae"></a>CSL_EPWM_HR_DELAY_EDGE_CTRL_RISING&#160;</td><td class="fielddoc">
<p>Delay inserted rising edge. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae843cd74e089d1082a6b9a6cf99cc8cca33c4b38f719aa038046022173c86da25"></a>CSL_EPWM_HR_DELAY_EDGE_CTRL_FALLING&#160;</td><td class="fielddoc">
<p>Delay inserted falling edge. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggae843cd74e089d1082a6b9a6cf99cc8cca3de62fa126eb1bfdbfa91e080f5bac8a"></a>CSL_EPWM_HR_DELAY_EDGE_CTRL_BOTH&#160;</td><td class="fielddoc">
<p>Delay inserted on both edges. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gad67e0340fa97724992f320582e9d4ff9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gad67e0340fa97724992f320582e9d4ff9">CSL_EpwmHrRegActLoad</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pulse selection, that selects which pulse to use for timing events in the HRPWM module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggad67e0340fa97724992f320582e9d4ff9a54a69205d13c3879fa5d8fe925c594c6"></a>CSL_EPWM_HR_REG_ACT_LOAD_CNT_ZRO_PULSE&#160;</td><td class="fielddoc">
<p>Select CNT_zero pulse. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggad67e0340fa97724992f320582e9d4ff9ac8f00d7fd57c80f168ba3d2ead37bfdd"></a>CSL_EPWM_HR_REG_ACT_LOAD_PRD_EQ_PULSE&#160;</td><td class="fielddoc">
<p>Select CNT_zero pulse. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4672abaa68fac187b71c0cb03c7280cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga4672abaa68fac187b71c0cb03c7280cb">CSL_EpwmOutputCh</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of supported EPWM outputs in a single epwm channel. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga4672abaa68fac187b71c0cb03c7280cbab7f6d360159df2f6eb2bd9840781007a"></a>CSL_EPWM_OUTPUT_CH_MIN&#160;</td><td class="fielddoc">
<p>Minimum value of enumeration. Used for input validation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4672abaa68fac187b71c0cb03c7280cba82733cc259cd89324d030efde59aa861"></a>CSL_EPWM_OUTPUT_CH_A&#160;</td><td class="fielddoc">
<p>Output channel A. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4672abaa68fac187b71c0cb03c7280cba391c9df922265c118516435d51715405"></a>CSL_EPWM_OUTPUT_CH_B&#160;</td><td class="fielddoc">
<p>Output channel B. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga4672abaa68fac187b71c0cb03c7280cba6c17bd99f9a99035efc40f108b993de3"></a>CSL_EPWM_OUTPUT_CH_MAX&#160;</td><td class="fielddoc">
<p>Maximum value of enumeration. Used for input validation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga94bff6472785045fba9b46f3d3d60890"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga94bff6472785045fba9b46f3d3d60890">CSL_EpwmShadowRegCtrl</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shadow register enable or disable control. </p>
<p>Same macros will be used to control the following shadow registers</p><ul>
<li>Time Base period register</li>
<li>Counter Comparator A register</li>
<li>Counter Comparator B register</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Same macros are used for controlling all the three registers because the field values are same for all these cases.<ul>
<li>Shadow enable = 0x0</li>
<li>Shadow disable = 0x1 In any case if these values changes across the above mentioned registers then separate macros need to be used.</li>
<li>Shadow enable macros with value 0x0<ul>
<li>PWMSS_EPWM_TBCTL_PRDLD_LOAD_FROM_SHADOW,</li>
<li>PWMSS_EPWM_CMPCTL_SHDWAMODE_SHADOW,</li>
<li>PWMSS_EPWM_CMPCTL_SHDWBMODE_SHADOW</li>
</ul>
</li>
<li>Shadow disable macros with value 0x1<ul>
<li>PWMSS_EPWM_TBCTL_PRDLD_LOAD_IMMEDIATELY</li>
<li>PWMSS_EPWM_CMPCTL_SHDWAMODE_IMMEDIATE</li>
<li>PWMSS_EPWM_CMPCTL_SHDWBMODE_IMMEDIATE </li>
</ul>
</li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga94bff6472785045fba9b46f3d3d60890a7a8dc0ecf53af94ee5d75c2c013a962e"></a>CSL_EPWM_SHADOW_REG_CTRL_ENABLE&#160;</td><td class="fielddoc">
<p>Shadow register value will be used. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga94bff6472785045fba9b46f3d3d60890a49145a26a25c386dac6abaec9d557a7d"></a>CSL_EPWM_SHADOW_REG_CTRL_DISABLE&#160;</td><td class="fielddoc">
<p>Shadow register is disabled and active register value will be used. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga2a8df9e04db9dab6fced318b9a1b4781"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga2a8df9e04db9dab6fced318b9a1b4781">CSL_EpwmTbCntDirAftSync</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counter directions after sync event. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga2a8df9e04db9dab6fced318b9a1b4781aa9ab8e7c57da41a371b870769cccbd4b"></a>CSL_EPWM_TB_CNT_DIR_AFT_SYNC_DOWN&#160;</td><td class="fielddoc">
<p>Count down after the synchronization event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga2a8df9e04db9dab6fced318b9a1b4781a74af69d36dd75c3a3a858fe5e90e9301"></a>CSL_EPWM_TB_CNT_DIR_AFT_SYNC_UP&#160;</td><td class="fielddoc">
<p>Count up after the synchronization event. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga36504709deb5986c35b50afa2cee8fe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga36504709deb5986c35b50afa2cee8fe7">CSL_EpwmTbCounterDir</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of Time base counter direction modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga36504709deb5986c35b50afa2cee8fe7a07dff478b3a4b55c95d57efd94bab4b7"></a>CSL_EPWM_TB_COUNTER_DIR_UP&#160;</td><td class="fielddoc">
<p>Up Count mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga36504709deb5986c35b50afa2cee8fe7ad11775a755ea7abb9c0dbf13a9ac736e"></a>CSL_EPWM_TB_COUNTER_DIR_DOWN&#160;</td><td class="fielddoc">
<p>Down count mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga36504709deb5986c35b50afa2cee8fe7a52ec32244b91b906a1c8b3e9ec5d6fd6"></a>CSL_EPWM_TB_COUNTER_DIR_UP_DOWN&#160;</td><td class="fielddoc">
<p>Up down count mode. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga36504709deb5986c35b50afa2cee8fe7aa58311ff6066c644f575f89fdf507187"></a>CSL_EPWM_TB_COUNTER_DIR_STOP&#160;</td><td class="fielddoc">
<p>stop-freeze counter operation (default on reset). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga193ed300ab9563ce954e632f8812654d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga193ed300ab9563ce954e632f8812654d">CSL_EpwmTbEmuMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emulation Mode. This selects the behaviour of the ePWM time-base counter during emulation events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga193ed300ab9563ce954e632f8812654dac3d8584ee88c1872013fda8767df279c"></a>CSL_EPWM_TB_EMU_MODE_STP_AFT_NEXT_CYCLE&#160;</td><td class="fielddoc">
<p>Stop after the next time-base counter increment or decrement. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga193ed300ab9563ce954e632f8812654da22e9885e361424dd0fc5e40b9b938d18"></a>CSL_EPWM_TB_EMU_MODE_STP_AFT_COMPLETE_CYCLE&#160;</td><td class="fielddoc">
<p>Stop after the next time-base counter increment or decrement. Up-count mode: stop when the time-base counter = period. Down-count mode: stop when the time-base counter = 0000. Up-down-count mode: stop when the time-base counter = 0000. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga193ed300ab9563ce954e632f8812654dae9e91cb0ce2c3fd8206861d5455dac1d"></a>EPWM_TB_EMU_MODE_FREE_RUN&#160;</td><td class="fielddoc">
<p>Counter is in Free run. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga30fb54bc86a56cd9527228699876db33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga30fb54bc86a56cd9527228699876db33">CSL_EpwmTbSts</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags to get the different types of time base status. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga30fb54bc86a56cd9527228699876db33a3295177e33da23c490ce72fc5a9d0e26"></a>EPWM_TB_STS_CTR_MAX&#160;</td><td class="fielddoc">
<p>Time-Base Counter Max Latched Status. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga30fb54bc86a56cd9527228699876db33ae1b54ab00327a469d6126f25f088cff7"></a>EPWM_TB_STS_SYNCI&#160;</td><td class="fielddoc">
<p>Input Synchronization Latched Status. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga30fb54bc86a56cd9527228699876db33a218eed14c2dc83e2a9948ee77e8db06d"></a>EPWM_TB_STS_CTR_DIR&#160;</td><td class="fielddoc">
<p>Time-Base Counter Direction Status. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga81b34cdcaad3341541b27c1cd96013a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga81b34cdcaad3341541b27c1cd96013a1">CSL_EpwmTbSyncOutEvt</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Source of Synchronization output signal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga81b34cdcaad3341541b27c1cd96013a1ad588d42ae5b01176c3ce9b6fe238fdef"></a>CSL_EPWM_TB_SYNC_OUT_EVT_SYNCIN&#160;</td><td class="fielddoc">
<p>Sync Input signal. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga81b34cdcaad3341541b27c1cd96013a1a63b4c4d19c895497403c3100cc14697d"></a>CSL_EPWM_TB_SYNC_OUT_EVT_CNT_EQ_ZERO&#160;</td><td class="fielddoc">
<p>Time-base counter equal to zero. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga81b34cdcaad3341541b27c1cd96013a1a16f93abf61d1e57163f982aed79fbb5b"></a>CSL_EPWM_TB_SYNC_OUT_EVT_CNT_EQ_CMP_B&#160;</td><td class="fielddoc">
<p>Time-base counter equal to counter-compare B (TBCNT = CMPB). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga81b34cdcaad3341541b27c1cd96013a1a40caee29ba9c279a3ff651d512d44e33"></a>CSL_EPWM_TB_SYNC_OUT_EVT_DISABLE&#160;</td><td class="fielddoc">
<p>Disable EPWMxSYNCO(Sync Output) signal. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gacdb6aa144118af5cb8445a6c02078b77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gacdb6aa144118af5cb8445a6c02078b77">CSL_EpwmTzEvent</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of trip zone events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggacdb6aa144118af5cb8445a6c02078b77a82262fc1074652c483208f21a151e6ef"></a>CSL_EPWM_TZ_EVENT_MIN&#160;</td><td class="fielddoc">
<p>Minimum value of enumeration. Used for input validation. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacdb6aa144118af5cb8445a6c02078b77a94bafd9cefecc18f8d2b6a8975c7f0cf"></a>CSL_EPWM_TZ_EVENT_ONE_SHOT&#160;</td><td class="fielddoc">
<p>One shot trip zone event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacdb6aa144118af5cb8445a6c02078b77aa7946206fffe1986becddf7936fc3311"></a>CSL_EPWM_TZ_EVENT_CYCLE_BY_CYCLE&#160;</td><td class="fielddoc">
<p>Cycle by cycle trip zone event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggacdb6aa144118af5cb8445a6c02078b77a18ae11ed17b7e053ddda6a80f6c1cb70"></a>CSL_EPWM_TZ_EVENT_MAX&#160;</td><td class="fielddoc">
<p>Maximum value of enumeration. Used for input validation. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga3fb1ccf4c19a96a1dfe82d0d995bacde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#ga3fb1ccf4c19a96a1dfe82d0d995bacde">CSL_EpwmTzStsFlg</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trip zone status flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga3fb1ccf4c19a96a1dfe82d0d995bacdea7504368543f2fbe76f8193b42cbe8c00"></a>CSL_EPWM_TZ_STS_FLG_OST&#160;</td><td class="fielddoc">
<p>Latched Status Flag for A One-Shot Trip Event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3fb1ccf4c19a96a1dfe82d0d995bacdea136349ed0c89a6b359506cd8c0c0f9d9"></a>CSL_EPWM_TZ_STS_FLG_CBC&#160;</td><td class="fielddoc">
<p>Latched Status Flag for Cycle-By-Cycle Trip Event. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga3fb1ccf4c19a96a1dfe82d0d995bacdea0ec542d1c722b605042c4879323f08a7"></a>CSL_EPWM_TZ_STS_FLG_INT&#160;</td><td class="fielddoc">
<p>Latched status for Trip Interrupt . </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa9c1aa65bb06a11eefbd84871d3deeb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___c_s_l___e_p_w_m.html#gaa9c1aa65bb06a11eefbd84871d3deeb2">CSL_EpwmTzTripAction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Action to be taken on PWM output When a trip event occurs. </p>
<p>Same macros will be used to control both A and B outputs because the bit field values are same for A and B channels.</p>
<dl class="section note"><dt>Note</dt><dd>The following are the similar macros<ul>
<li>Tri state action macro with value 0x0<ul>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_IMPEDANCE</li>
<li>PWMSS_EPWM_TZCTL_TZB_HIGH_IMPEDANCE</li>
</ul>
</li>
<li>High action macro with value 0x1<ul>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_STATE</li>
<li>PWMSS_EPWM_TZCTL_TZA_HIGH_STATE</li>
</ul>
</li>
<li>Low action macro with value 0x2<ul>
<li>PWMSS_EPWM_TZCTL_TZA_LOW_STATE</li>
<li>PWMSS_EPWM_TZCTL_TZB_LOW_STATE</li>
</ul>
</li>
<li>Do nothing action macro with value 0x3<ul>
<li>PWMSS_EPWM_TZCTL_TZA_DO_NOTHING</li>
<li>PWMSS_EPWM_TZCTL_TZB_DO_NOTHING </li>
</ul>
</li>
</ul>
</dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa9c1aa65bb06a11eefbd84871d3deeb2a8787e7040baa5408bff07be9d6dc8710"></a>CSL_EPWM_TZ_TRIP_ACTION_TRI_STATE&#160;</td><td class="fielddoc">
<p>High impedance (EPWMxA = High-impedance state). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa9c1aa65bb06a11eefbd84871d3deeb2a059886e19557d89f0d895ca495d7baf9"></a>CSL_EPWM_TZ_TRIP_ACTION_HIGH&#160;</td><td class="fielddoc">
<p>Force EPWMxA to a high state. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa9c1aa65bb06a11eefbd84871d3deeb2a630b4738913d8cc34b3f2451cf47602a"></a>CSL_EPWM_TZ_TRIP_ACTION_LOW&#160;</td><td class="fielddoc">
<p>Force EPWMxA to a low state. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaa9c1aa65bb06a11eefbd84871d3deeb2a6b1e7a2bf2b0e8f60a0eca9e0f154dcc"></a>CSL_EPWM_TZ_TRIP_ACTION_DO_NOTHING&#160;</td><td class="fielddoc">
<p>Do nothing, no action is taken on EPWMxA. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga1fc5067aa5e5a90ee10b896dd912a7d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmAqActionOnOutputCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmOutputCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_p_w_m.html#gaaa3bc020da4d3d9c9c13d5259e44e2ad">CSL_EpwmAqActionCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the action to be taken on output by the Action qualifier module upon receiving the events. This will determine the output waveform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pwmOutputCh</td><td>PWM Output channel type either A or B 'pwmOutputCh' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabbbbb6eda9084cd2713ae3a282f38170" title="Number of supported EPWM outputs in a single epwm channel. ">CSL_EpwmOutputCh_t</a>.</li>
</ul>
</td></tr>
    <tr><td class="paramname">pCfg</td><td>Pointer to the following structure which contains the action configuration variables for different events<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gaaa3bc020da4d3d9c9c13d5259e44e2ad" title="Structure holding the Action Qualifier actions to be taken on the PWM output at the specific events...">CSL_EpwmAqActionCfg_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Each event can be configured to one of the following enum values.<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga805c562b6cb0b8523e4e2c9eede3a1b4" title="Types of Actions that Action Qualifier can take on the Output when the supported counter compare even...">CSL_EpwmAqAction_t</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab659bf7153e07a716955b1041a83b7e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmAqSwTriggerContAction </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmOutputCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swTrigAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>activeRegReloadMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API forces output value continuously on PWM output channel. The output can be forced to low or high. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pwmOutputCh</td><td>PWM Output channel type either A or B 'pwmOutputCh' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabbbbb6eda9084cd2713ae3a282f38170" title="Number of supported EPWM outputs in a single epwm channel. ">CSL_EpwmOutputCh_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">swTrigAction</td><td>Value to be forced on the output This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga31c16860974e7b6a52688da47566539c" title="Types of Continuous software forced actions on output. ">CSL_EpwmAqSwTrigContAction_t</a> </li>
</ul>
</td></tr>
    <tr><td class="paramname">activeRegReloadMode</td><td>Shadow to active reg load trigger. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga4ea8bd98b5b6ad3840721cfaf74664d8" title="Action Qualifier Software Force Active Register Reload From Shadow Options. ">CSL_EpwmAqCsfrcRegReload_t</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94dcc6812f81713d1de771192f25996f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmAqSwTriggerOneTimeAction </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmOutputCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>swTrigAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API triggers the SW forced single event on the PWM output. </p>
<p>This can be used for testing the AQ sub-module. Every call to this API will trigger a single event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pwmOutputCh</td><td>PWM Output channel type either A or B 'pwmOutputCh' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabbbbb6eda9084cd2713ae3a282f38170" title="Number of supported EPWM outputs in a single epwm channel. ">CSL_EpwmOutputCh_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">swTrigAction</td><td>Action that needs to be taken on the PWM output. 'swTrigAction' can take one of the following enum values<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gae5436d5c1b122f8d49b6702f2d5e88cc" title="Actions to be taken on the output, when Software triggered one time events will occur. ">CSL_EpwmAqSwTrigOtAction_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae12f7f88391a3459181789d911f8184b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmChopperCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_p_w_m.html#ga494e3bbf20e23cebda4ffb422961c7ba">CSL_EpwmChopperCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API performs the configuration of the chopper sub-module. This API configures chopping clock duty cycle, chopping clock frequency and pulse width of first pulse of chopping clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pCfg</td><td>Pointer to the structure <a class="el" href="group___c_s_l___e_p_w_m.html#ga494e3bbf20e23cebda4ffb422961c7ba" title="Structure holding the configuration parameters of Chopper sub-module. ">CSL_EpwmChopperCfg_t</a> containing the chopper configuration parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga04dd41f4f5a88637ec8927237ee5b14c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmChopperEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enableChopper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API controls the enabling or disabling of chopper sub-module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">enableChopper</td><td>Flag controlling the enabling or disabling 'enableChopper' can take one of the following values<ul>
<li>TRUE - Enable chopper</li>
<li>FALSE - Disable chopper </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac23f0ca8fa2be253fadfaf43ef0e906c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmClockDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions disables clock for EPWM sub-module in the PWM subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API disables the clock for the EPWM module which is present inside the PWM subsystem. The clocks for the PWM Sub system will be disabled inside the PRCM module. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f858a36044cd3052f6e4fd7e3dd73dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmClockEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions enables clock for EPWM module in PWM subsystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API enables the clock for the EPWM module which is present inside the PWM subsystem. The clocks for the PWM Sub system will be enabled inside the PRCM module. </dd></dl>

</div>
</div>
<a class="anchor" id="gabbfb18a2d74589338daee3a6a134755c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t CSL_epwmCounterComparatorCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmpType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmpVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enableShadowWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>shadowToActiveLoadTrigger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>overwriteShadow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the counter comparator and loads the comparator value. When Counter comparator value equals the counter value, then an event is generated both in the up direction and down direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">cmpType</td><td>Comparator Type A or B. 'cmpType' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga4095133466d3bd0f770d832c0c671f5d">CSL_EpwmCcCmp_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">cmpVal</td><td>Comparator value that needs to be loaded. </td></tr>
    <tr><td class="paramname">enableShadowWrite</td><td>Enable write to shadow register. 'enableShadowWrite' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga6f7a09a63c915d6a04097a58b4af1008" title="Shadow register enable or disable control. ">CSL_EpwmShadowRegCtrl_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">shadowToActiveLoadTrigger</td><td>Shadow to active register load mode. 'shadowToActiveLoadTrigger' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gaa49bb59c3a7915b1715fd9bdf453072e" title="Counter-Comparator registers(A and B) load mode flags from shadow register. ">CSL_EpwmCcCmpLoadMode_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">overwriteShadow</td><td>Overwrite even if previous value is not loaded to active register. 'overwriteShadow' can take following values<ul>
<li>TRUE</li>
<li>FALSE</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TRUE</td><td>Comparator value is written successfully. </td></tr>
    <tr><td class="paramname">FALSE</td><td>Comparator value write is failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab645593e6d1a96dfabe0abe10123c067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmDeadbandBypass </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API bypasses the Dead-band sub-module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0c5cc1dc58a505405457936ad6f39042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmDeadbandCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___c_s_l___e_p_w_m.html#gad4201245ce28a464ac9e1493d06f19f9">CSL_EpwmDeadbandCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pCfg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API performs the configuration of the dead band sub-module. This API configures the input source, output mode, polarity, rising and falling edge delays. </p>
<p>The Dead band generator has two sub-modules, one for raising edge delay and the other for falling edge delay. This can be configured when a delay is need between two signals during signal change. The dead band generator is useful in full-inverters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">pCfg</td><td>Pointer to the structure <a class="el" href="group___c_s_l___e_p_w_m.html#gad4201245ce28a464ac9e1493d06f19f9" title="Structure holding the dead band generation sub-module configuration parameters. ">CSL_EpwmDeadbandCfg_t</a> containing the dead band configuration parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c2bd0a2f385993fb695645bd6c3d25e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmEtGetEventCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the number of events occurred. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">eventCount</td><td>number of events occurred. This will have values in the range 0 to 3. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga74eb5ae3c209861ea82d0ed0fdc7f470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrEvtSrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrPrd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the Event Trigger sub-module. This API configures the interrupt source and interrupt period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">intrEvtSrc</td><td>Event source which triggers interrupt. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga542ee551a622c54100853d42223597b4" title="ePWM Interrupt (EPWMx_INT) Selection Options. ">CSL_EpwmEtIntrEvt_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">intrPrd</td><td>prescalar value(This determines how may selected events need to occur before an interrupt is generated). This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gacecebb3e46dae00e204b6bdba8d7ebb2" title="ePWM Interrupt (EPWMx_INT) Period Select. These values determine how many selected events need to occ...">CSL_EpwmEtIntrPeriod_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac24fe4e9590ee1541fcba7291c4d723e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the interrupt. This will clear the interrupt flag bit and enable further interrupts pulses to be generated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga13e5ad7cd49e5b96face61a0a9258f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the ePWM Event interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae500d137bbc0d0fdfc2586081f68f24d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the ePWM Event interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5c3da844c980fb123495fa49b1b0657c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmEtIntrStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the ePWM event interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>Interrupt is not generated. </td></tr>
    <tr><td class="paramname">1</td><td>Interrupt is generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae17259d0151ecfee6757522aab0b4495"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmEtIntrTrigger </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API forces interrupt to be generated. This API is used for testing purpose. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab9ff5ba3d8875103bcf78f4a5805728d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmHighResolutionCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ctrlMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mepCtrlEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures control mode and edge mode of high resolution sub-module. In also enables the HR sub-module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">ctrlMode</td><td>phase control or duty control. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga92f26c15c4ab3a8d58492b3a50831e54" title="Delay Bus Selection, that selects which bus is used to select the delay for the PWM pulse...">CSL_EpwmHrDelayBusSelMode_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">mepCtrlEdge</td><td>Edge on which MEP to be applied.(rising,falling,both) This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gaac587cbead83f9079cbcf9f066e7e9a8" title="Delay Mode Configuration, that selects which edge of the PWM pulse the delay is inserted. ">CSL_EpwmHrDelayEdgeCtrl_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>High-resolution feature is supported only on PWM-A channel output. </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf038e58613cb1f2bdc693540a66d4a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmHighResolutionDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the high-resolution feature of ePWM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafe35535163f5e72300c3d6add88d634b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmHrLoadCmpAHrValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>compAHighResVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ShadowToActiveLoadTrigger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API loads Counter-Comparator A high resolution value and also configure the pulse select bits, that select which pulse to use for timing events in the HRPWM module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">compAHighResVal</td><td>Counter-comparator A high resolution value </td></tr>
    <tr><td class="paramname">ShadowToActiveLoadTrigger</td><td>Condition when the active reg to be loaded. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga593ac8153b1dd188574f3e6e00db96d0" title="Pulse selection, that selects which pulse to use for timing events in the HRPWM module. ">CSL_EpwmHrRegActLoad_t</a>; </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b6c9b6b308290a2b0f47b437d447f9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmHrLoadTbPhaseHrValue </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbPhsHighResVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API loads the Timebase Phase high resolution register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbPhsHighResVal</td><td>Time-base phase high resolution value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7071efede364ce48b46fcc63ed44c325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmTbGetStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbStatusMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the Time Base status as indicated by the tbStatusMask parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbStatusMask</td><td>Flag indicating the type of status needed. 'tbStatusMask' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gab6740927d05ff40e51dece1c1205a265" title="Flags to get the different types of time base status. ">CSL_EpwmTbSts_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">tbStatus</td><td>Requested status is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The returned status will depend on the status mask passed.<ul>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gga30fb54bc86a56cd9527228699876db33a3295177e33da23c490ce72fc5a9d0e26">EPWM_TB_STS_CTR_MAX</a><ol type="1">
<li>Zero indicates the time-base counter never reached its max value.</li>
<li>NonZero indicates that the time-base counter reached max value 0xFFFF</li>
</ol>
</li>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gga30fb54bc86a56cd9527228699876db33ae1b54ab00327a469d6126f25f088cff7">EPWM_TB_STS_SYNCI</a><ol type="1">
<li>Zero indicates that no external synchronization event has occurred.</li>
<li>NonZero indicates that an external synchronization event has occurred.</li>
</ol>
</li>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gga30fb54bc86a56cd9527228699876db33a218eed14c2dc83e2a9948ee77e8db06d">EPWM_TB_STS_CTR_DIR</a><ol type="1">
<li>Zero indicates that Time-Base Counter is currently counting down.</li>
<li>NonZero indicates that Time-Base Counter is currently counting up. </li>
</ol>
</li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga1fa6c5056eb541841419c7e6a3160717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbPwmFreqCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counterDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enableShadowWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the PWM Time base counter Frequency/Period. </p>
<p>The period count determines the period of the final output waveform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbClk</td><td>Timebase clock in Hz. </td></tr>
    <tr><td class="paramname">pwmFreq</td><td>Frequency of the PWM Output in Hz. </td></tr>
    <tr><td class="paramname">counterDir</td><td>Direction of the counter(up, down, up-down). 'counterDir' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gad49eb987b4b1bdfaf306d388088754f5" title="Types of Time base counter direction modes. ">CSL_EpwmTbCounterDir_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">enableShadowWrite</td><td>Flag controlling Whether write to Period register is to be shadowed or not. 'enableShadowWrite' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga6f7a09a63c915d6a04097a58b4af1008" title="Shadow register enable or disable control. ">CSL_EpwmShadowRegCtrl_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the counter direction is configured as <a class="el" href="group___c_s_l___e_p_w_m.html#gga36504709deb5986c35b50afa2cee8fe7a52ec32244b91b906a1c8b3e9ec5d6fd6">CSL_EPWM_TB_COUNTER_DIR_UP_DOWN</a>, then output frequency will be half the value of required pwm frequency. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3debb795a5a3c567ff4a5f6f2fb3a564"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmTbReadTbCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API gets the Time base counter current value. The count operation is not affected by the read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">tbCount</td><td>Current Timebase count value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaefe04ef2e88a21414b917aa167c68407"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbSetEmulationMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures emulation mode. This setting determines the behaviour of Timebase counter during emulation (debugging). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">mode</td><td>Emulation mode. 'mode' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gadbc0d33deb92c765bb6eecaa4c6bfbd6" title="Emulation Mode. This selects the behaviour of the ePWM time-base counter during emulation events...">CSL_EpwmTbEmuMode_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1783f1d4e175c768ed350467659065ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbSetSyncOutMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>syncOutMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API selects the source of the synchronization output signal. It determines on which of the supported events sync-out has to be generated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">syncOutMode</td><td>Sync out mode. 'syncOutMode' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gaf843e98441ebc2edf21ad5c354e2855d" title="Source of Synchronization output signal. ">CSL_EpwmTbSyncOutEvt_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00629ad2136740cb2fc5a5ac3db12d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbStatusClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbStatusClrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the Time base status bits indicated by the tbStatusClrMask parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbStatusClrMask</td><td>Mask indicating which status bit need to be cleared 'tbStatusClrMask' can take following values<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gga30fb54bc86a56cd9527228699876db33a3295177e33da23c490ce72fc5a9d0e26">EPWM_TB_STS_CTR_MAX</a></li>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gga30fb54bc86a56cd9527228699876db33ae1b54ab00327a469d6126f25f088cff7">EPWM_TB_STS_SYNCI</a> </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f4c56932cad3819d7cc735c4695fd28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbSyncDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the synchronization. Even if sync-in event occurs the count value will not be reloaded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga94a7f77c01cb831a7935fdfd6e766091"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbSyncEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbPhsValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counterDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the synchronization of time base sub-module and also configures the phase count value to be loaded after sync event, counter direction after sync event. </p>
<p>When a sync-in event is generated the the time base counter is reloaded with the new value. After sync the counter will use the new value and direction as specified after sync event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbPhsValue</td><td>Phase value to be reloaded after sync </td></tr>
    <tr><td class="paramname">counterDir</td><td>Count direction after sync. 'counterDir' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga7569a66aaa8b0d5ca68e009762c09abc" title="Counter directions after sync event. ">CSL_EpwmTbCntDirAftSync_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaccc86de57b0138e374b106003c07fdf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbTimebaseClkCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbClk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>moduleClk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the clock divider of the Time base module. </p>
<p>The clock divider can be calculated using the equation TBCLK = SYSCLKOUT/(HSPCLKDIV × CLKDIV)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbClk</td><td>Timebase clock to be generated in Hz. </td></tr>
    <tr><td class="paramname">moduleClk</td><td>Input clock of the PWM module (sysclk2) in Hz. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9b88fd8c50ffc905cea62f8bf9dc1598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbTriggerSwSync </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API generates software triggered sync pulse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This API can be used for testing. When this API is called sync-in event will be generated. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3602d386ffb1b55d7cb6660e5b878d8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTbWriteTbCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tbCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API loads the Time base counter. The new value is taken immediately. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tbCount</td><td>Time base count value to be loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae33ecda8dfa28260ef573327fd1e0822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t CSL_epwmTzEventStatus </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API returns the selected trip zone event status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">eventMask</td><td>Type of status which has to be read. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga677ca062d4c7ecb97857775e28f1a7e0" title="Trip zone status flags. ">CSL_EpwmTzStsFlg_t</a>.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Status</td><td>Status of the required status flag.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The return status depends on the type of status flag passed.<ol type="1">
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gga3fb1ccf4c19a96a1dfe82d0d995bacdea7504368543f2fbe76f8193b42cbe8c00">CSL_EPWM_TZ_STS_FLG_OST</a><ol type="a">
<li>Zero - No one-shot trip event has occurred.</li>
<li>NonZero - Indicates a trip event has occurred on a pin selected as a one-shot trip source.</li>
</ol>
</li>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gga3fb1ccf4c19a96a1dfe82d0d995bacdea136349ed0c89a6b359506cd8c0c0f9d9">CSL_EPWM_TZ_STS_FLG_CBC</a><ol type="a">
<li>Zero - No cycle-by-cycle trip event has occurred.</li>
<li>NonZero - Indicates a trip event has occurred on a pin selected as a cycle-by-cycle trip source.</li>
</ol>
</li>
<li>For <a class="el" href="group___c_s_l___e_p_w_m.html#gga3fb1ccf4c19a96a1dfe82d0d995bacdea0ec542d1c722b605042c4879323f08a7">CSL_EPWM_TZ_STS_FLG_INT</a><ol type="a">
<li>Zero - Indicates no interrupt has been generated.</li>
<li>NonZero - Indicates an EPWMxTZINT interrupt was generated because of a trip condition. </li>
</ol>
</li>
</ol>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga76cff74a105d8bbd78350d8f1367dc86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzEventStatusClear </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API clears the selected trip zone event status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">eventMask</td><td>Type of status which has to be read. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga677ca062d4c7ecb97857775e28f1a7e0" title="Trip zone status flags. ">CSL_EpwmTzStsFlg_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaea8cead002b55aad5f7346e1a192cbba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzIntrDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disables the trip interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Trip zone event for which interrupt has to be enabled. This parameter can take values form the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabb57b10cbea2b0be2acfe603b4c46648" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga174736f224abc925a0474a5ee48c5552"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzIntrEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the trip interrupt. When trip event occurs the sub-module can be configured to interrupt CPU. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Trip zone event for which interrupt has to be enabled. This parameter can take values form the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabb57b10cbea2b0be2acfe603b4c46648" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad424481c3b6ba56fd734c942efd81075"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzTriggerSwEvent </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables to generate Software forced trip condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Type of trip condition which has to be generated. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabb57b10cbea2b0be2acfe603b4c46648" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65025ed62bdb842f6a520c83a7cfac19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzTriggerTripAction </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tripAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pwmOutputCh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API configures the o/p on PWM channel when a trip event is recognized. The output can be set to high or low or high impedance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tripAction</td><td>Action to be taken on the PWM output. This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#ga6bf2f55aca379fc7846538bed71ef049" title="Action to be taken on PWM output When a trip event occurs. ">CSL_EpwmTzTripAction_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pwmOutputCh</td><td>PWM Output channel type either A or B 'pwmOutputCh' can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabbbbb6eda9084cd2713ae3a282f38170" title="Number of supported EPWM outputs in a single epwm channel. ">CSL_EpwmOutputCh_t</a>. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0b2360ef51b088052085727d89752bb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzTripEventDisable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API disable the trip event. The disabled trip events will be ignored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Disable OST or CBC trip zone event This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabb57b10cbea2b0be2acfe603b4c46648" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pinNum</td><td>Pin number on which trip zone event has to be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7a425c0124749de1ab5e877f2f529491"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CSL_epwmTzTripEventEnable </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tzEventType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pinNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API enables the trip event. </p>
<p>The trip signals indicates external fault, and the ePWM outputs can be programmed to respond accordingly when faults occur.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseAddr</td><td>Base Address of PWMSS instance used. </td></tr>
    <tr><td class="paramname">tzEventType</td><td>Enable OST or CBC trip zone event This parameter can take values from the following enum<ul>
<li><a class="el" href="group___c_s_l___e_p_w_m.html#gabb57b10cbea2b0be2acfe603b4c46648" title="Type of trip zone events. ">CSL_EpwmTzEvent_t</a>. </li>
</ul>
</td></tr>
    <tr><td class="paramname">pinNum</td><td>Pin number on which trip zone event has to be enabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
