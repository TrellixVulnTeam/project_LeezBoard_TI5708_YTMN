<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TIMER Functions</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="../../tilogo.gif"></a></td>
  <td bgcolor="red"><img src="../../titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TIMER Functions<div class="ingroups"><a class="el" href="group___c_s_l___t_i_m_e_r___a_p_i.html">TIMER</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga433b8155230278303edfa143f6d32d7f"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit</a> (<a class="el" href="struct_c_s_l___tmr_context.html">CSL_TmrContext</a> *pContext)</td></tr>
<tr class="separator:ga433b8155230278303edfa143f6d32d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a7a881ca80009b84971ca5fbf7930bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen</a> (<a class="el" href="struct_c_s_l___tmr_obj.html">CSL_TmrObj</a> *pTmrObj, CSL_InstNum tmrNum, <a class="el" href="struct_c_s_l___tmr_param.html">CSL_TmrParam</a> *pTmrParam, CSL_Status *pStatus)</td></tr>
<tr class="separator:ga2a7a881ca80009b84971ca5fbf7930bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e5f2ca2db798b71ee2d169d5b26c4cf"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga3e5f2ca2db798b71ee2d169d5b26c4cf">CSL_tmrGetBaseAddress</a> (CSL_InstNum tmrNum, <a class="el" href="struct_c_s_l___tmr_param.html">CSL_TmrParam</a> *pTmrParam, <a class="el" href="struct_c_s_l___tmr_base_address.html">CSL_TmrBaseAddress</a> *pBaseAddress)</td></tr>
<tr class="separator:ga3e5f2ca2db798b71ee2d169d5b26c4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72247216e27be847e84d2521c3d69eed"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga72247216e27be847e84d2521c3d69eed">CSL_tmrClose</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:ga72247216e27be847e84d2521c3d69eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43ceae654ca190a40369268c12e20117"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga43ceae654ca190a40369268c12e20117">CSL_tmrHwSetup</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, const <a class="el" href="struct_c_s_l___tmr_hw_setup.html">CSL_TmrHwSetup</a> *hwSetup)</td></tr>
<tr class="separator:ga43ceae654ca190a40369268c12e20117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af4acda6a35745afda45073ddb86ad7"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga7af4acda6a35745afda45073ddb86ad7">CSL_tmrHwControl</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga25974e4e04f4cf89c765c8d16b9736fc">CSL_TmrHwControlCmd</a> cmd, const void *arg)</td></tr>
<tr class="separator:ga7af4acda6a35745afda45073ddb86ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ab1943f2173806eb6f90a16ee1b9c9"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga08ab1943f2173806eb6f90a16ee1b9c9">CSL_tmrGetHwStatus</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga1c6869706a6734ec55df7505559b6755">CSL_TmrHwStatusQuery</a> query, void *response)</td></tr>
<tr class="separator:ga08ab1943f2173806eb6f90a16ee1b9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0022a28fa0a01b6887cdabde2aba4f00"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga0022a28fa0a01b6887cdabde2aba4f00">CSL_tmrHwSetupRaw</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, const <a class="el" href="struct_c_s_l___tmr_config.html">CSL_TmrConfig</a> *config)</td></tr>
<tr class="separator:ga0022a28fa0a01b6887cdabde2aba4f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab53b4761d15e2cd2868c4b6792ed7ab4"><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gab53b4761d15e2cd2868c4b6792ed7ab4">CSL_tmrGetHwSetup</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, <a class="el" href="struct_c_s_l___tmr_hw_setup.html">CSL_TmrHwSetup</a> *hwSetup)</td></tr>
<tr class="separator:gab53b4761d15e2cd2868c4b6792ed7ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1947147253e396082cae9a6541b1d67a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga1947147253e396082cae9a6541b1d67a">CSL_tmrGetTimHiCount</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, Uint32 *countHi)</td></tr>
<tr class="separator:ga1947147253e396082cae9a6541b1d67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83c1fd726723246ba58bbf959bbb1871"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga83c1fd726723246ba58bbf959bbb1871">CSL_tmrGetTimLoCount</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, Uint32 *countLo)</td></tr>
<tr class="separator:ga83c1fd726723246ba58bbf959bbb1871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8dc5e815b8cb18c2264d3c449e42d73"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga0258c62d1ac88f2ac97c91984da3f658">CSL_TmrTstat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gab8dc5e815b8cb18c2264d3c449e42d73">CSL_tmrGetTstatLoStatus</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:gab8dc5e815b8cb18c2264d3c449e42d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga039497fa55d0fd3062a65abbc1704618"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga0258c62d1ac88f2ac97c91984da3f658">CSL_TmrTstat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga039497fa55d0fd3062a65abbc1704618">CSL_tmrGetTstatHiStatus</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:ga039497fa55d0fd3062a65abbc1704618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5260ec9b0808eea500ad923e159ff9c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga7105881a8649bcb54f75039e9780e6f2">CSL_TmrWdflagBitStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga5260ec9b0808eea500ad923e159ff9c5">CSL_tmrGetWdflagStatus</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:ga5260ec9b0808eea500ad923e159ff9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1595209b8a4a6c13016a2d3107e5ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga8b1595209b8a4a6c13016a2d3107e5ad">CSL_TmrLoadPrdLo</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, const Uint32 *loadVal)</td></tr>
<tr class="separator:ga8b1595209b8a4a6c13016a2d3107e5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb22f2ad57dd1192cd3458838e39c302"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gacb22f2ad57dd1192cd3458838e39c302">CSL_TmrLoadPrdHi</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, const Uint32 *loadVal)</td></tr>
<tr class="separator:gacb22f2ad57dd1192cd3458838e39c302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62a32baee1231cdafa58b37bd211940f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga62a32baee1231cdafa58b37bd211940f">CSL_TmrLoadRelLo</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, const Uint32 *loadVal)</td></tr>
<tr class="separator:ga62a32baee1231cdafa58b37bd211940f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4769e77c2605dd199b22495b74cf98e6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga4769e77c2605dd199b22495b74cf98e6">CSL_TmrLoadRelHi</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, const Uint32 *loadVal)</td></tr>
<tr class="separator:ga4769e77c2605dd199b22495b74cf98e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac73889206210869be6558bb1adb7e9c5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gac73889206210869be6558bb1adb7e9c5">CSL_TmrLoadPrescalarHi</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, const Uint8 *loadVal)</td></tr>
<tr class="separator:gac73889206210869be6558bb1adb7e9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94807b25cc75c611c9d04766b4dc370c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga94807b25cc75c611c9d04766b4dc370c">CSL_TmrStartHi</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga40c8e3c921713914c2e9153c04790d29">CSL_TmrEnamode</a> countMode)</td></tr>
<tr class="separator:ga94807b25cc75c611c9d04766b4dc370c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf893b504f7c7f48ae88416f71603328"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gaaf893b504f7c7f48ae88416f71603328">CSL_TmrStartLo</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga40c8e3c921713914c2e9153c04790d29">CSL_TmrEnamode</a> countMode)</td></tr>
<tr class="separator:gaaf893b504f7c7f48ae88416f71603328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9b50fe634659fecf3d119535e8522e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gabc9b50fe634659fecf3d119535e8522e">CSL_TmrStart64</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga40c8e3c921713914c2e9153c04790d29">CSL_TmrEnamode</a> countMode)</td></tr>
<tr class="separator:gabc9b50fe634659fecf3d119535e8522e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga529aea16e9f97a0d3bfb5aac7d68519e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga529aea16e9f97a0d3bfb5aac7d68519e">CSL_TmrStopLo</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:ga529aea16e9f97a0d3bfb5aac7d68519e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46cba5fe34e835219e362a6736ce2ce4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga46cba5fe34e835219e362a6736ce2ce4">CSL_TmrStopHi</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:ga46cba5fe34e835219e362a6736ce2ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccba79ac3f27a76a224068db08b6c7f8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gaccba79ac3f27a76a224068db08b6c7f8">CSL_TmrStop64</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:gaccba79ac3f27a76a224068db08b6c7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17d121d0b6ff25ade30b9d67288213a3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga17d121d0b6ff25ade30b9d67288213a3">CSL_TmrResetHi</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:ga17d121d0b6ff25ade30b9d67288213a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace35bca0563622a76f729f6444a43c03"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gace35bca0563622a76f729f6444a43c03">CSL_TmrResetLo</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:gace35bca0563622a76f729f6444a43c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fb04c41d48c30e8cd7b9529e180c034"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga8fb04c41d48c30e8cd7b9529e180c034">CSL_TmrReset64</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:ga8fb04c41d48c30e8cd7b9529e180c034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8759902111446dca7dc583a1c1301e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#gae8759902111446dca7dc583a1c1301e4">CSL_TmrStartWdt</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga40c8e3c921713914c2e9153c04790d29">CSL_TmrEnamode</a> countMode)</td></tr>
<tr class="separator:gae8759902111446dca7dc583a1c1301e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d6b7981786a5883b9bb44bf593c555a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga7d6b7981786a5883b9bb44bf593c555a">CSL_TmrLoadWdkey</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr, Uint16 cmd)</td></tr>
<tr class="separator:ga7d6b7981786a5883b9bb44bf593c555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f1edb555466af5037c15a0f14d66948"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2f1edb555466af5037c15a0f14d66948">CSL_TmrDisableWdt</a> (<a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> hTmr)</td></tr>
<tr class="separator:ga2f1edb555466af5037c15a0f14d66948"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga72247216e27be847e84d2521c3d69eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_tmrClose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrClose</b> </p>
<p><b>Description</b> <br />
 This function marks that CSL for the GP timer instance is closed. CSL for the GP timer instance need to be reopened before using any GP timer CSL API.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hTmr         Timer handle to be closed.</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 1. The GP timer CSL APIs can not be called until the GP timer CSL is reopened again using <a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></p>
<p><b>Writes</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_status      status;
         CSL_TmrObj      tmrObj;
         CSL_TmrHandle   hTmr;
         CSL_TmrContext  context;

         // Initialize the Timer Module.
         CSL_tmrInit(&amp;context);
         ...
         // Open TIMER 0
         hTmr = CSL_tmrOpen(&amp;tmrObj, 0, NULL, &amp;status);
         ...
         // Close the timer.
         CSL_tmrClose(hTmr);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2f1edb555466af5037c15a0f14d66948"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrDisableWdt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrDisableWdt</b> </p>
<p><b>Description</b> The function disables the Watch Dog Timer.</p>
<p><b>Arguments</b> </p><pre class="fragment">     hTmr         Handle to the Timer instance</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 The Watch Dog timer is disabled.</p>
<p><b>Writes</b> <br />
 TMR_WDTCR_WDEN=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hWdt;
     ...
     CSL_TmrDisableWdt(hWdt);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga3e5f2ca2db798b71ee2d169d5b26c4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_tmrGetBaseAddress </td>
          <td>(</td>
          <td class="paramtype">CSL_InstNum&#160;</td>
          <td class="paramname"><em>tmrNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___tmr_param.html">CSL_TmrParam</a> *&#160;</td>
          <td class="paramname"><em>pTmrParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___tmr_base_address.html">CSL_TmrBaseAddress</a> *&#160;</td>
          <td class="paramname"><em>pBaseAddress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrGetBaseAddress</b> </p>
<p><b>Description</b> <br />
 This function gets the base address of the given GPTIMER instance.</p>
<p><b>Arguments</b> </p><pre class="fragment">         tmrNum        Specifies the instance of the gptimer to be opened
         pTmrParam     TIMER module specific parameters
         pBaseAddress  Pointer to base address structure containing base
                       address details</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_FAIL (Timer Instance is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Affects</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_Status            status;
     CSL_TmrBaseAddress    baseAddress;
     CSL_TmrContext  context;

     // Initialize the Timer Module.
     CSL_tmrInit(&amp;context);
     ...
     // Get the base address for TIMER Instance 0.
     status = CSL_tmrGetBaseAddress(0, NULL, &amp;baseAddress);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab53b4761d15e2cd2868c4b6792ed7ab4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_tmrGetHwSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___tmr_hw_setup.html">CSL_TmrHwSetup</a> *&#160;</td>
          <td class="paramname"><em>hwSetup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrGetHwSetup</b> </p>
<p><b>Description</b> <br />
 It retrives the hardware setup parameters</p>
<p><b>Arguments</b> </p><pre class="fragment">         hTmr            Handle to the timer instance
         hwSetup         Pointer to hardware setup structure populated by this API</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 The hardware set up structure will be populated with values from the registers</p>
<p><b>Reads</b> <br />
 TMR_PRDLO_PRDLO,TMR_PRDHI_PRDHI,TMR_CNTLO_CNT,TMR_CNT_CNTHI,TMR_TCR_TIEN_HI,TMR_TCR_CLKSRC_HI, TMR_TCR_PWID_HI,TMR_TCR_CP_HI,TMR_TCR_INVINP_HI,TMR_TCR_INVOUTP_HI,TMR_TCR_TIEN_LO,TMR_TCR_CLKSRC_LO, TMR_TCR_PWID_LO,TMR_TCR_CP_LO,TMR_TCR_INVINP_LO,TMR_TCR_INVOUTP_LO,TMR_TGCR_PSCHI,TMR_TGCR_TIMMODE,</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_status      status;
         CSL_TmrObj      tmrObj;
         CSL_TmrHandle   hTmr;
         CSL_TmrContext  context;
         CSL_TmrConfig   config;

         // Initialize the Timer Module.
         CSL_tmrInit(&amp;context);
         ...
         // Open TIMER 0
         hTmr = CSL_tmrOpen(&amp;tmrObj, 0, NULL, &amp;status);
         ...
         // Get the current timer configuration the timer with the 'defaults'
         CSL_tmrGetHwsetup (hTmr, &amp;config);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga08ab1943f2173806eb6f90a16ee1b9c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_tmrGetHwStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga1c6869706a6734ec55df7505559b6755">CSL_TmrHwStatusQuery</a>&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_tmrGetHwStatus</b> </p>
<p><b>Description</b> <br />
 This function is used to get the value of various parameters of the timer instance. The value returned depends on the query passed.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hTmr            Handle to the timer instance
         query           Query to be performed
         response        Pointer to buffer to return the data requested by
                         the query passed</pre><p><b> Return Value </b> CSL_Status <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVQUERY (The query passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> Data requested by the query is returned through the variable "response"</p>
<p><b>Reads</b> <br />
 TMR_CNTLO_CNT;TMR_CNTHI_CNT;TMR_TCR_TSTAT_LO;TMR_TCR_TSTAT_HI;TMR_WDTCR_WDFLAG</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_status      status;
         CSL_TmrObj      tmrObj;
         CSL_TmrHandle   hTmr;
         CSL_TmrContext  context;
         Uint32          response;

         // Initialize the Timer Module.
         CSL_tmrInit(&amp;context);
         ...
         // Open TIMER 0
         hTmr = CSL_tmrOpen(&amp;tmrObj, 0, NULL, &amp;status);
         ...
         // Get the value of LOW Count for Timer 0.
         CSL_tmrGetHwStatus(hTmr, CSL_TMR_QUERY_COUNT_LO, &amp;response);</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga1947147253e396082cae9a6541b1d67a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_tmrGetTimHiCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>countHi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrGetTimHiCount</b> </p>
<p><b>Description</b> <br />
 This function gets the value of the CNTHI counter</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Pointer to the object that holds reference to the
                  instance of TIMER requested after the call
      countHi     Output parameter to get the CNTHI value</pre><p><b> Return Value </b> <br />
 The argument countHi is populated with the contents of the CNTHI register</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TMR_CNTHI_CNT</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle   hTmr;
     Unit32*         countHi;
     ...
     CSL_tmrGetTimHiCount(hTmr, &amp;countHi);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga83c1fd726723246ba58bbf959bbb1871"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_tmrGetTimLoCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>countLo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_tmrGetTimLoCount</b> </p>
<p><b>Description</b> <br />
 This function gets the value of the CNTLO counter</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr       Pointer to the object that holds reference to the
                 instance of TIMER requested after the call
      countLo    Output parameter to get the CNTLO value</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 The argument countLo is populated with the contents of the CNTLO register</p>
<p><b>Reads</b> <br />
 TMR_CNTLO_CNT</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     Unit32        *countLo;
     ...
     CSL_tmrGetTimLoCount(hTmr, &amp;countLo);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga039497fa55d0fd3062a65abbc1704618"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga0258c62d1ac88f2ac97c91984da3f658">CSL_TmrTstat</a> CSL_tmrGetTstatHiStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_tmrGetTstatHiStatus</b> </p>
<p><b>Description</b> <br />
 This function gets the status of the TINTHI</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr   Pointer to the object that holds reference to the
             instance of TIMER requested after the call</pre><p><b> Return Value </b> <br />
 CSL_TmrTstatHi - TINTHI status value </p><ul>
<li>CSL_TMR_TSTATHI_LOW - Data low </li>
<li>CSL_TMR_TSTATHI_HIGH - Data High</li>
</ul>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TMR_TCR_TSTAT_HI</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle  hTmr;
     CSL_TmrTstatHi statusHi;
     ...
     statusHi = CSL_tmrGetTstatHiStatus(hTmr);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gab8dc5e815b8cb18c2264d3c449e42d73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga0258c62d1ac88f2ac97c91984da3f658">CSL_TmrTstat</a> CSL_tmrGetTstatLoStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_tmrGetTstatLoStatus</b> </p>
<p><b>Description</b> <br />
 This function gets the status of the TINTLO</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr   Pointer to the object that holds reference to the
             instance of TIMER requested after the call</pre><p><b> Return Value </b> <br />
 CSL_TmrTstatLo - TINTLO status value </p><ul>
<li>CSL_TMR_TSTAT_LO_LOW - Data low </li>
<li>CSL_TMR_TSTAT_LO_HIGH - Data High</li>
</ul>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TMR_TCR_TSTAT_LO</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle  hTmr;
     CSL_TmrTstatLo statusLo;
     ...
     statusLo = CSL_tmrGetTstatLoStatus(hTmr);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga5260ec9b0808eea500ad923e159ff9c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga7105881a8649bcb54f75039e9780e6f2">CSL_TmrWdflagBitStatus</a> CSL_tmrGetWdflagStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_tmrGetWdflagStatus</b> </p>
<p><b>Description</b> <br />
 This function gets the status of the WDFLAG</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr   Pointer to the object that holds reference to the
             instance of TIMER requested after the call</pre><p><b> Return Value </b> <br />
 CSL_TmrFlagBitStatus - WDFLAG status value </p><ul>
<li>CSL_TMR_WDFLAG_NOTIMEOUT - no watchdog timeout occurred </li>
<li>CSL_TMR_WDFLAG_TIMEOUT - watchdog timeout occurred</li>
</ul>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called and the Timer should be set in WATCHDOG mode</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Reads</b> <br />
 TMR_WDTCR_WDFLAG</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle          hTmr;
     CSL_TmrWdflagBitStatus status;
     ...
     status = CSL_tmrGetWdflagStatus(hTmr);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7af4acda6a35745afda45073ddb86ad7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_tmrHwControl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga25974e4e04f4cf89c765c8d16b9736fc">CSL_TmrHwControlCmd</a>&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrHwControl</b> </p>
<p><b>Description</b> <br />
 This function performs various control operations on the timer instance, based on the command passed.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hTmr         Handle to the timer instance
         cmd          Operation to be performed on the timer
         cmdArg       Argument specific to the command</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid) <br />
 Error - CSL_ESYS_INVCMD (The command passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Registers of the timer instance are configured according to the command and the command arguments. The command determines which registers are modified.</p>
<p><b>Writes</b> <br />
 TMR_PRDLO_PRDLO; TMR_PRDHI_PRDHI; TMR_TGCR_PSCHI; TMR_TGCR_TIMLORS=1,TMR_TCR_ENAMODE_LO; TMR_TGCR_TIMHIRS=1,TMR_TCR_ENAMODE_HI; TMR_TCR_ENAMODE_LO=0; TMR_TCR_ENAMODE_HI=0; TMR_TGCR_TIMLORS=0; TMR_TGCR_TIMHIRS=0; TMR_TGCR_TIMLORS=1,TMR_TGCR_TIMHIRS=1, TMR_TCR_ENAMODE_LO,TMR_TCR_ENAMODE_HI; TMR_TCR_ENAMODE_LO=0,TMR_TCR_ENAMODE_HI=0; TMR_TGCR_TIMLORS=0,TMR_TGCR_TIMHIRS=0; TMR_TGCR_TIMLORS=1,TMR_TGCR_TIMHIRS=1,TMR_WDTCR_WDEN=1,TMR_TCR_ENAMODE_LO,TMR_TCR_ENAMODE_HI; TMR_WDTCR_WDKEY</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_status      status;
         CSL_TmrObj      tmrObj;
         CSL_TmrHandle   hTmr;
         CSL_TmrContext  context;

         // Initialize the Timer Module.
         CSL_tmrInit(&amp;context);
         ...
         // Open TIMER 0
         hTmr = CSL_tmrOpen(&amp;tmrObj, 0, NULL, &amp;status);
         ...
         // Start the LO Timer.
         CSL_tmrHwControl(hTmr, CSL_TMR_CMD_START_TIMLO, NULL);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga43ceae654ca190a40369268c12e20117"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_tmrHwSetup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___tmr_hw_setup.html">CSL_TmrHwSetup</a> *&#160;</td>
          <td class="paramname"><em>hwSetup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrHwSetup</b> </p>
<p><b>Description</b> <br />
 It configures the timer instance registers as per the values passed in the hardware setup structure.</p>
<p><b>Arguments</b> </p><pre class="fragment">         htmr        Handle to the timer instance
         setup       Pointer to hardware setup structure populated by 
                     this API</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 The specified instance will be setup according to value passed</p>
<p><b>Writes</b> <br />
 TMR_PRDLO_PRDLO,TMR_PRDHI_PRDHI,TMR_CNTLO_CNT,TMR_CNTHI_CNT, TMR_TCR_TIEN_HI,TMR_TCR_CLKSRC_HI,TMR_TCR_PWID_HI,TMR_TCR_CP_HI,TMR_TCR_INVINP_HI, TMR_TCR_INVOUTP_HI,TMR_TCR_TIEN_LO,TMR_TCR_CLKSRC_LO,TMR_TCR_PWID_LO,TMR_TCR_CP_LO, TMR_TCR_INVINP_LO, TMR_TCR_INVOUTP_LO,TMR_TGCR_PSCHI,TMR_TGCR_TIMMODE,</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_status      status;
         CSL_TmrObj      tmrObj;
         CSL_TmrHandle   hTmr;
         CSL_TmrContext  context;
         CSL_tmrHwSetup  hwSetup;

         // Initialize the Timer Module.
         CSL_tmrInit(&amp;context);
         ...
         // Open TIMER 0
         hTmr = CSL_tmrOpen(&amp;tmrObj, 0, NULL, &amp;status);
         ...
         // Get the Hardware Setup for Timer 0.        
         CSL_tmrHwSetup(htmr, &amp;hwSetup);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga0022a28fa0a01b6887cdabde2aba4f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_tmrHwSetupRaw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_c_s_l___tmr_config.html">CSL_TmrConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrHwSetupRaw</b> </p>
<p><b>Description</b> <br />
 This function initializes the device registers with the register-values provided through the config data structure.</p>
<p><b>Arguments</b> </p><pre class="fragment">         hTmr            Pointer to the object that holds reference to the
                         instance of TIMER requested after the call
         config          Pointer to the config structure containing the
                         device register values</pre><p><b> Return Value </b> <br />
 Success - CSL_SOK <br />
 Error - CSL_ESYS_BADHANDLE (The handle passed is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 The registers of the specified General purpose timer instance will be setup according to the values passed through the config structure</p>
<p><b>Writes</b> <br />
 TMR_CNTLO_CNT,TMR_CNTHI_CNT,TMR_PRDLO_PRDLO,TMR_PRDHI_PRDHI,TMR_TCR_TCR,TMR_TGCR_TGCR, TMR_WDTCR_WDTCR</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_status      status;
         CSL_TmrObj      tmrObj;
         CSL_TmrHandle   hTmr;
         CSL_TmrContext  context;
         CSL_TmrConfig   config = CSL_TMR_CONFIG_DEFAULTS;

         // Initialize the Timer Module.
         CSL_tmrInit(&amp;context);
         ...
         // Open TIMER 0
         hTmr = CSL_tmrOpen(&amp;tmrObj, 0, NULL, &amp;status);
         ...
         // Configure the timer with the 'defaults'
         CSL_tmrHwSetupRaw (hTmr, &amp;config);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga433b8155230278303edfa143f6d32d7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status CSL_tmrInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___tmr_context.html">CSL_TmrContext</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrInit</b> </p>
<p><b>Description</b> <br />
 This is the initialization function for the General purpose timer CSL. The function must be called before calling any other API from this CSL. This function is idem-potent. Currently, the function just return status CSL_SOK, without doing anything.</p>
<p><b>Arguments</b> </p><pre class="fragment">     pContext    Pointer to module-context. As General purpose timer doesn't
                 have any context based information user is expected to pass
                 NULL.</pre><p><b> Return Value </b> <br />
 Always returns Success - CSL_SOK</p>
<p><b> Pre Condition </b> <br />
 None</p>
<p><b> Post Condition </b> <br />
 The CSL for gptimer is initialized</p>
<p><b>Writes</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_TmrContext  context;

         // Initialize the Timer Module.
         CSL_tmrInit(&amp;context);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gacb22f2ad57dd1192cd3458838e39c302"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrLoadPrdHi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>loadVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_TmrLoadPrdHi</b> </p>
<p><b>Description</b> Loads the General purpose timer HIGH period register</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the GPtimer instance
      loadVal     Value to be loaded to the Gptimer period register High</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Period register is loaded with the given value.</p>
<p><b>Writes</b> <br />
 TMR_PRDHI_PRDHI</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle   hTmr;
     Uint32          loadVal;
     ...
     loadVal = 10;
     CSL_TmrLoadPrdHi(hWdt, &amp;loadVal);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8b1595209b8a4a6c13016a2d3107e5ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrLoadPrdLo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>loadVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_TmrLoadPrdLo</b> </p>
<p><b>Description</b> Loads the General purpose timer LOW period register.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Gptimer instance
      loadVal     Value to be loaded to the Gptimer period register Low</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Period register is loaded with the given value.</p>
<p><b>Writes</b> <br />
 TMR_PRDLO_PRDLO</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     Uint32       loadVal;

     loadVal = 10;
     CSL_TmrLoadPrdLo(hWdt, &amp;loadVal);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gac73889206210869be6558bb1adb7e9c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrLoadPrescalarHi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint8 *&#160;</td>
          <td class="paramname"><em>loadVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_TmrLoadPrescalarHi</b> </p>
<p><b>Description</b> Configures the prescalar values for the HIGH Timer.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Timer Instance
      loadVal     Value to be loaded to the PRESCALAR bits in the TGCR register</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Gptimer pre scalar register is loaded with the given value.</p>
<p><b>Writes</b> <br />
 TMR_TGCR_PSCHI</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     Uint8         *loadVal;
     ...
     CSL_TmrLoadPrescalarHi(hWdt, &amp;loadVal);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga4769e77c2605dd199b22495b74cf98e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrLoadRelHi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>loadVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_TmrLoadRelHi</b> </p>
<p><b>Description</b> Loads the General purpose timer HIGH reload register</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the GPtimer instance
      loadVal     Value to be loaded to the Gptimer reload register High</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Reload register is loaded with the given value.</p>
<p><b>Writes</b> <br />
 TMR_RELHI_RELHI</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle   hTmr;
     Uint32          loadVal;
     ...
     loadVal = 10;
     CSL_TmrLoadRelHi(hWdt, &amp;loadVal);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga62a32baee1231cdafa58b37bd211940f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrLoadRelLo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>loadVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_TmrLoadRelLo</b> </p>
<p><b>Description</b> Loads the General purpose timer LOW reload register.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Gptimer instance
      loadVal     Value to be loaded to the Gptimer reload register Low</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Reload register is loaded with the given value.</p>
<p><b>Writes</b> <br />
 TMR_RELLO_RELLO</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     Uint32       loadVal;

     loadVal = 10;
     CSL_TmrLoadRelLo(hWdt, &amp;loadVal);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga7d6b7981786a5883b9bb44bf593c555a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrLoadWdkey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrLoadtWdkey</b> </p>
<p><b>Description</b> The function loads the watch dog timer with the appropriate key.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Gptimer instance
      cmd         Specifies the WATCHDOG Key. This can only be either of 
                  the following:-
                     - CSL_TMR_WDTCR_WDKEY_CMD1
                     - CSL_TMR_WDTCR_WDKEY_CMD2</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Loads the WDKEY in WDTCR register.</p>
<p><b>Writes</b> <br />
 TMR_WDTCR_WDKEY</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hWdt;
     ...
     CSL_TmrLoadWdkey(hWdt, CSL_TMR_WDTCR_WDKEY_CMD1);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga2a7a881ca80009b84971ca5fbf7930bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a> CSL_tmrOpen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___tmr_obj.html">CSL_TmrObj</a> *&#160;</td>
          <td class="paramname"><em>pTmrObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_InstNum&#160;</td>
          <td class="paramname"><em>tmrNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_s_l___tmr_param.html">CSL_TmrParam</a> *&#160;</td>
          <td class="paramname"><em>pTmrParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>pStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_tmrOpen</b> </p>
<p><b>Description</b> <br />
 This function populates the peripheral data object for the TIMER instance and returns a handle to the instance. The open call sets up the data structures for the particular instance of TIMER device. The device can be re-opened anytime after it has been normally closed if so required. The handle returned by this call is input as an essential argument for rest of the APIs described for this module.</p>
<p><b>Arguments</b> </p><pre class="fragment">         tmrObj          Pointer to GPTIMER object.
         tmrNum          Instance of GPTIMER CSL to be opened.
         pTmrParam       Module specific parameters.
         status          Status of the function call</pre><p><b> Return Value </b> <br />
 Success - Valid Timer Handle <br />
 Error - CSL_ESYS_FAIL (The Timer Instance is invalid) <br />
 Error - CSL_ESYS_INVPARAMS (The parameter passed is invalid)</p>
<p><b> Pre Condition </b> <br />
 <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 None</p>
<p><b>Writes</b> <br />
 None</p>
<p><b>Example</b> </p><pre class="fragment">         CSL_status      status;
         CSL_TmrObj      tmrObj;
         CSL_TmrHandle   hTmr;
         CSL_TmrContext  context;

         // Initialize the Timer Module.
         CSL_tmrInit(&amp;context);
         ...
         // Open TIMER 0
         hTmr = CSL_tmrOpen(&amp;tmrObj, 0, NULL, &amp;status);
         ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga8fb04c41d48c30e8cd7b9529e180c034"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrReset64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrReset64</b> </p>
<p><b>Description</b> The function resets the 64bit timer.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Timer instance</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 64bit Timer is reset.</p>
<p><b>Writes</b> <br />
 TMR_TGCR_TIMLORS=0,TMR_TGCR_TIMHIRS=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     ...
     CSL_TmrReset64(hTmr);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga17d121d0b6ff25ade30b9d67288213a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrResetHi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrResetHi</b> </p>
<p><b>Description</b> The HIGH timer is moved to RESET state.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the HIGH timer instance</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 High timer is reset.</p>
<p><b>Writes</b> <br />
 TMR_TGCR_TIMHIRS=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     ...
     CSL_TmrResetHi(hTmr);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gace35bca0563622a76f729f6444a43c03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrResetLo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrResetLo</b> </p>
<p><b>Description</b> The LOW timer is moved to RESET state.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Gptimer instance</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Low Timer is Reset</p>
<p><b>Writes</b> <br />
 TMR_TGCR_TIMLORS=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     ...
     CSL_TmrResetLo(hWdt);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gabc9b50fe634659fecf3d119535e8522e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrStart64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga40c8e3c921713914c2e9153c04790d29">CSL_TmrEnamode</a>&#160;</td>
          <td class="paramname"><em>countMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrStart64</b> </p>
<p><b>Description</b> The function starts the 64bit Timer by bringing both the LOW and HIGH timer out of reset.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Gptimer instance
      countMode   Specifies the timer counting mode (OFF/CONTINIOUS/SINGLE Shot)</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Set the GP OR chained timer counting mode and timer Low and High reset register.</p>
<p><b>Writes</b> <br />
 TMR_TGCR_TIMLORS=1,TMR_TGCR_TIMHIRS=1, <br />
 TMR_TCR_ENAMODE_LO,TMR_TCR_ENAMODE_HI</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle  hTmr;
     ...
     CSL_TmrStart64(hTmr, CSL_TMR_ENAMODE_ENABLE);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga94807b25cc75c611c9d04766b4dc370c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrStartHi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga40c8e3c921713914c2e9153c04790d29">CSL_TmrEnamode</a>&#160;</td>
          <td class="paramname"><em>countMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_TmrStartHi</b> </p>
<p><b>Description</b> The functions starts the HIGH timer.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Timer instance
      countMode   Specifies the timer counting mode (OFF/CONTINIOUS/SINGLE Shot)</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 The HIGH timer is brought out of reset and is activated in the provided counting mode.</p>
<p><b>Writes</b> <br />
 TMR_TGCR_TIMHIRS=1,TMR_TCR_ENAMODE_HI</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle  hTmr;
     ...
     CSL_TmrStartHi(hTmr, CSL_TMR_ENAMODE_ENABLE);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaaf893b504f7c7f48ae88416f71603328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrStartLo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga40c8e3c921713914c2e9153c04790d29">CSL_TmrEnamode</a>&#160;</td>
          <td class="paramname"><em>countMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>============================================================================ <br />
<b>CSL_TmrStartLo</b> </p>
<p><b>Description</b> The function starts the LOW Timer.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Gptimer instance
      countMode   Specifies the timer counting mode (OFF/CONTINIOUS/SINGLE Shot)</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 The LOW timer is brought out of reset and is activated in the provided counting mode.</p>
<p><b>Writes</b> <br />
 TMR_TGCR_TIMLORS=1,TMR_TCR_ENAMODE_LO</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle  hTmr;
     ...
     CSL_TmrStartLo(hTmr, CSL_TMR_ENAMODE_ENABLE);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gae8759902111446dca7dc583a1c1301e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrStartWdt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___e_n_u_m.html#ga40c8e3c921713914c2e9153c04790d29">CSL_TmrEnamode</a>&#160;</td>
          <td class="paramname"><em>countMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrStartWdt</b> </p>
<p><b>Description</b> The function starts the timer in Watch Dog Mode.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Timer instance
      countMode   Specifies the timer counting mode (OFF/CONTINIOUS/SINGLE Shot)</pre><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Timer has been started in WATCH Dog Mode.</p>
<p><b>Writes</b> <br />
 TMR_TGCR_TIMLORS=1,TMR_TGCR_TIMHIRS=1,TMR_WDTCR_WDEN=1,TMR_TCR_ENAMODE_LO,TMR_TCR_ENAMODE_HI;</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle  hWdt;
     ...
     CSL_TmrStartWdt(hWdt, CSL_TMR_ENAMODE_CONT);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="gaccba79ac3f27a76a224068db08b6c7f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrStop64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrStop64</b> </p>
<p><b>Description</b> The function stops the 64bit timer.</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Timer instance</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 The 64bit timer is stopped</p>
<p><b>Writes</b> <br />
 TMR_TCR_ENAMODE_LO=0,TMR_TCR_ENAMODE_HI=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     ...
     CSL_TmrStop64(hWdt);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga46cba5fe34e835219e362a6736ce2ce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrStopHi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrStopHi</b> </p>
<p><b>Description</b> The function stops the HIGH Timer</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Timer instance</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 High Timer is disabled.</p>
<p><b>Writes</b> <br />
 TMR_TCR_ENAMODE_HI=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     ...
     CSL_TmrStopHi(hTmr);
     ...</pre><hr/>
 
</div>
</div>
<a class="anchor" id="ga529aea16e9f97a0d3bfb5aac7d68519e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void CSL_TmrStopLo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___c_s_l___t_i_m_e_r___d_a_t_a_s_t_r_u_c_t.html#ga4dea5cad07a11ea540c22285813a2893">CSL_TmrHandle</a>&#160;</td>
          <td class="paramname"><em>hTmr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>=========================================================================== <br />
<b>CSL_TmrStopLo</b> </p>
<p><b>Description</b> The function stops the LOW Timer</p>
<p><b>Arguments</b> </p><pre class="fragment">      hTmr        Handle to the Timer instance</pre><p><b> Return Value </b> <br />
 None</p>
<p><b> Pre Condition </b> <br />
 Both <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga433b8155230278303edfa143f6d32d7f">CSL_tmrInit()</a></em> and <em><a class="el" href="group___c_s_l___t_i_m_e_r___f_u_n_c_t_i_o_n.html#ga2a7a881ca80009b84971ca5fbf7930bb">CSL_tmrOpen()</a></em> must be called.</p>
<p><b> Post Condition </b> <br />
 Low Timer is disabled.</p>
<p><b>Writes</b> <br />
 TMR_TCR_ENAMODE_LO=0</p>
<p><b>Example</b> </p><pre class="fragment">     CSL_TmrHandle hTmr;
     ...
     CSL_TmrStopLo(hTmr);
     ...</pre><hr/>
 
</div>
</div>
</div><!-- contents -->
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
